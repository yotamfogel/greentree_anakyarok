{"version":3,"file":"react-window.cjs","sources":["../lib/utils/isRtl.ts","../lib/core/useIsRtl.ts","../lib/hooks/useIsomorphicLayoutEffect.ts","../lib/utils/parseNumericStyleValue.ts","../lib/hooks/useResizeObserver.ts","../lib/hooks/useStableCallback.ts","../lib/utils/getRTLOffsetType.ts","../lib/utils/adjustScrollOffsetForRtl.ts","../lib/utils/assert.ts","../lib/utils/shallowCompare.ts","../lib/core/getEstimatedSize.ts","../lib/core/getOffsetForIndex.ts","../lib/core/getStartStopIndices.ts","../lib/core/createCachedBounds.ts","../lib/core/useCachedBounds.ts","../lib/core/useItemSize.ts","../lib/core/useVirtualizer.ts","../lib/hooks/useMemoizedObject.ts","../lib/utils/arePropsEqual.ts","../lib/components/grid/Grid.tsx","../lib/components/grid/useGridCallbackRef.ts","../lib/components/grid/useGridRef.ts","../lib/components/list/isDynamicRowHeight.ts","../lib/components/list/List.tsx","../lib/components/list/useDynamicRowHeight.ts","../lib/components/list/useListCallbackRef.ts","../lib/components/list/useListRef.ts","../lib/utils/getScrollbarSize.ts"],"sourcesContent":["export function isRtl(element: HTMLElement) {\n  let currentElement: HTMLElement | null = element;\n  while (currentElement) {\n    if (currentElement.dir) {\n      return currentElement.dir === \"rtl\";\n    }\n\n    currentElement = currentElement.parentElement;\n  }\n\n  return false;\n}\n","import { useLayoutEffect, useState, type HTMLAttributes } from \"react\";\nimport { isRtl } from \"../utils/isRtl\";\n\nexport function useIsRtl(\n  element: HTMLElement | null,\n  dir: HTMLAttributes<HTMLElement>[\"dir\"]\n) {\n  const [value, setValue] = useState(dir === \"rtl\");\n\n  useLayoutEffect(() => {\n    if (element) {\n      if (!dir) {\n        setValue(isRtl(element));\n      }\n    }\n  }, [dir, element]);\n\n  return value;\n}\n","import { useEffect, useLayoutEffect } from \"react\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import type { CSSProperties } from \"react\";\n\nexport function parseNumericStyleValue(\n  value: CSSProperties[\"height\"]\n): number | undefined {\n  if (value !== undefined) {\n    switch (typeof value) {\n      case \"number\": {\n        return value;\n      }\n      case \"string\": {\n        if (value.endsWith(\"px\")) {\n          return parseFloat(value);\n        }\n        break;\n      }\n    }\n  }\n}\n","import { useMemo, useState, type CSSProperties } from \"react\";\nimport { parseNumericStyleValue } from \"../utils/parseNumericStyleValue\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\nexport function useResizeObserver({\n  box,\n  defaultHeight,\n  defaultWidth,\n  disabled: disabledProp,\n  element,\n  mode,\n  style\n}: {\n  box?: ResizeObserverBoxOptions;\n  defaultHeight?: number;\n  defaultWidth?: number;\n  disabled?: boolean;\n  element: HTMLElement | null;\n  mode?: \"only-height\" | \"only-width\";\n  style: CSSProperties | undefined;\n}) {\n  const { styleHeight, styleWidth } = useMemo(\n    () => ({\n      styleHeight: parseNumericStyleValue(style?.height),\n      styleWidth: parseNumericStyleValue(style?.width)\n    }),\n    [style?.height, style?.width]\n  );\n\n  const [state, setState] = useState<{\n    height: number | undefined;\n    width: number | undefined;\n  }>({\n    height: defaultHeight,\n    width: defaultWidth\n  });\n\n  const disabled =\n    disabledProp ||\n    (mode === \"only-height\" && styleHeight !== undefined) ||\n    (mode === \"only-width\" && styleWidth !== undefined) ||\n    (styleHeight !== undefined && styleWidth !== undefined);\n\n  useIsomorphicLayoutEffect(() => {\n    if (element === null || disabled) {\n      return;\n    }\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { contentRect, target } = entry;\n        if (element === target) {\n          setState((prevState) => {\n            if (\n              prevState.height === contentRect.height &&\n              prevState.width === contentRect.width\n            ) {\n              return prevState;\n            }\n\n            return {\n              height: contentRect.height,\n              width: contentRect.width\n            };\n          });\n        }\n      }\n    });\n    resizeObserver.observe(element, { box });\n\n    return () => {\n      resizeObserver?.unobserve(element);\n    };\n  }, [box, disabled, element, styleHeight, styleWidth]);\n\n  return useMemo(\n    () => ({\n      height: styleHeight ?? state.height,\n      width: styleWidth ?? state.width\n    }),\n    [state, styleHeight, styleWidth]\n  );\n}\n","import { useCallback, useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\n// Forked from useEventCallback (usehooks-ts)\nexport function useStableCallback<Args, Return>(\n  fn: (args: Args) => Return\n): (args: Args) => Return {\n  const ref = useRef<typeof fn>(() => {\n    throw new Error(\"Cannot call an event handler while rendering.\");\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback((args: Args) => ref.current?.(args), [ref]) as (\n    args: Args\n  ) => Return;\n}\n","export type RTLOffsetType =\n  | \"negative\"\n  | \"positive-descending\"\n  | \"positive-ascending\";\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n\n    outerDiv.appendChild(innerDiv);\n\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = \"positive-descending\";\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = \"negative\";\n      } else {\n        cachedRTLResult = \"positive-ascending\";\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","import type { Direction } from \"../core/types\";\nimport { getRTLOffsetType } from \"./getRTLOffsetType\";\n\nexport function adjustScrollOffsetForRtl({\n  containerElement,\n  direction,\n  isRtl,\n  scrollOffset\n}: {\n  containerElement: HTMLElement | null;\n  direction: Direction;\n  isRtl: boolean;\n  scrollOffset: number;\n}) {\n  // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n  // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n  // So we need to determine which browser behavior we're dealing with, and mimic it.\n  if (direction === \"horizontal\") {\n    if (isRtl) {\n      switch (getRTLOffsetType()) {\n        case \"negative\": {\n          return -scrollOffset;\n        }\n        case \"positive-descending\": {\n          if (containerElement) {\n            const { clientWidth, scrollLeft, scrollWidth } = containerElement;\n            return scrollWidth - clientWidth - scrollLeft;\n          }\n          break;\n        }\n      }\n    }\n  }\n  return scrollOffset;\n}\n","export function assert(\n  expectedCondition: unknown,\n  message: string = \"Assertion error\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n\n    throw Error(message);\n  }\n}\n","import { assert } from \"./assert\";\n\nexport function shallowCompare<Type extends object>(\n  a: Type | undefined,\n  b: Type | undefined\n) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!!a !== !!b) {\n    return false;\n  }\n\n  assert(a !== undefined);\n  assert(b !== undefined);\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (!Object.is(b[key], a[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { CachedBounds, SizeFunction } from \"./types\";\nimport { assert } from \"../utils/assert\";\n\nexport function getEstimatedSize<Props extends object>({\n  cachedBounds,\n  itemCount,\n  itemSize\n}: {\n  cachedBounds: CachedBounds;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n}) {\n  if (itemCount === 0) {\n    return 0;\n  } else if (typeof itemSize === \"number\") {\n    return itemCount * itemSize;\n  } else {\n    const bounds = cachedBounds.get(\n      cachedBounds.size === 0 ? 0 : cachedBounds.size - 1\n    );\n    assert(bounds !== undefined, \"Unexpected bounds cache miss\");\n\n    const averageItemSize =\n      (bounds.scrollOffset + bounds.size) / cachedBounds.size;\n\n    return itemCount * averageItemSize;\n  }\n}\n","import type { Align } from \"../types\";\nimport { getEstimatedSize } from \"./getEstimatedSize\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function getOffsetForIndex<Props extends object>({\n  align,\n  cachedBounds,\n  index,\n  itemCount,\n  itemSize,\n  containerScrollOffset,\n  containerSize\n}: {\n  align: Align;\n  cachedBounds: CachedBounds;\n  index: number;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n  containerScrollOffset: number;\n  containerSize: number;\n}) {\n  const estimatedTotalSize = getEstimatedSize({\n    cachedBounds,\n    itemCount,\n    itemSize\n  });\n\n  const bounds = cachedBounds.get(index);\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - containerSize, bounds.scrollOffset)\n  );\n  const minOffset = Math.max(\n    0,\n    bounds.scrollOffset - containerSize + bounds.size\n  );\n\n  if (align === \"smart\") {\n    if (\n      containerScrollOffset >= minOffset &&\n      containerScrollOffset <= maxOffset\n    ) {\n      align = \"auto\";\n    } else {\n      align = \"center\";\n    }\n  }\n\n  switch (align) {\n    case \"start\": {\n      return maxOffset;\n    }\n    case \"end\": {\n      return minOffset;\n    }\n    case \"center\": {\n      if (bounds.scrollOffset <= containerSize / 2) {\n        // Too near the beginning to center-align\n        return 0;\n      } else if (\n        bounds.scrollOffset + bounds.size / 2 >=\n        estimatedTotalSize - containerSize / 2\n      ) {\n        // Too near the end to center-align\n        return estimatedTotalSize - containerSize;\n      } else {\n        return bounds.scrollOffset + bounds.size / 2 - containerSize / 2;\n      }\n    }\n    case \"auto\":\n    default: {\n      if (\n        containerScrollOffset >= minOffset &&\n        containerScrollOffset <= maxOffset\n      ) {\n        return containerScrollOffset;\n      } else if (containerScrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n}\n","import type { CachedBounds } from \"./types\";\n\nexport function getStartStopIndices({\n  cachedBounds,\n  containerScrollOffset,\n  containerSize,\n  itemCount,\n  overscanCount\n}: {\n  cachedBounds: CachedBounds;\n  containerScrollOffset: number;\n  containerSize: number;\n  itemCount: number;\n  overscanCount: number;\n}): {\n  startIndexVisible: number;\n  stopIndexVisible: number;\n  startIndexOverscan: number;\n  stopIndexOverscan: number;\n} {\n  const maxIndex = itemCount - 1;\n\n  let startIndexVisible = 0;\n  let stopIndexVisible = -1;\n  let startIndexOverscan = 0;\n  let stopIndexOverscan = -1;\n  let currentIndex = 0;\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (bounds.scrollOffset + bounds.size > containerScrollOffset) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  startIndexVisible = currentIndex;\n  startIndexOverscan = Math.max(0, startIndexVisible - overscanCount);\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (\n      bounds.scrollOffset + bounds.size >=\n      containerScrollOffset + containerSize\n    ) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  stopIndexVisible = Math.min(maxIndex, currentIndex);\n  stopIndexOverscan = Math.min(itemCount - 1, stopIndexVisible + overscanCount);\n\n  if (startIndexVisible < 0) {\n    startIndexVisible = 0;\n    stopIndexVisible = -1;\n    startIndexOverscan = 0;\n    stopIndexOverscan = -1;\n  }\n\n  return {\n    startIndexVisible,\n    stopIndexVisible,\n    startIndexOverscan,\n    stopIndexOverscan\n  };\n}\n","import { assert } from \"../utils/assert\";\nimport type { Bounds, CachedBounds, SizeFunction } from \"./types\";\n\nexport function createCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  const cache = new Map<number, Bounds>();\n\n  return {\n    get(index: number) {\n      assert(index < itemCount, `Invalid index ${index}`);\n\n      while (cache.size - 1 < index) {\n        const currentIndex = cache.size;\n\n        let size: number;\n        switch (typeof itemSize) {\n          case \"function\": {\n            size = itemSize(currentIndex, itemProps);\n            break;\n          }\n          case \"number\": {\n            size = itemSize;\n            break;\n          }\n        }\n\n        if (currentIndex === 0) {\n          cache.set(currentIndex, {\n            size,\n            scrollOffset: 0\n          });\n        } else {\n          const previousRowBounds = cache.get(currentIndex - 1);\n          assert(\n            previousRowBounds !== undefined,\n            `Unexpected bounds cache miss for index ${index}`\n          );\n\n          cache.set(currentIndex, {\n            scrollOffset:\n              previousRowBounds.scrollOffset + previousRowBounds.size,\n            size\n          });\n        }\n      }\n\n      const bounds = cache.get(index);\n      assert(\n        bounds !== undefined,\n        `Unexpected bounds cache miss for index ${index}`\n      );\n\n      return bounds;\n    },\n    set(index: number, bounds: Bounds) {\n      cache.set(index, bounds);\n    },\n    get size() {\n      return cache.size;\n    }\n  };\n}\n","import { useMemo } from \"react\";\nimport { createCachedBounds } from \"./createCachedBounds\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function useCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  return useMemo(\n    () =>\n      createCachedBounds({\n        itemCount,\n        itemProps,\n        itemSize\n      }),\n    [itemCount, itemProps, itemSize]\n  );\n}\n","import { assert } from \"../utils/assert\";\nimport type { SizeFunction } from \"./types\";\n\nexport function useItemSize<Props extends object>({\n  containerSize,\n  itemSize: itemSizeProp\n}: {\n  containerSize: number;\n  itemSize: number | string | SizeFunction<Props>;\n}) {\n  let itemSize: number | SizeFunction<Props>;\n  switch (typeof itemSizeProp) {\n    case \"string\": {\n      assert(\n        itemSizeProp.endsWith(\"%\"),\n        `Invalid item size: \"${itemSizeProp}\"; string values must be percentages (e.g. \"100%\")`\n      );\n      assert(\n        containerSize !== undefined,\n        \"Container size must be defined if a percentage item size is specified\"\n      );\n\n      itemSize = (containerSize * parseInt(itemSizeProp)) / 100;\n      break;\n    }\n    default: {\n      itemSize = itemSizeProp;\n      break;\n    }\n  }\n\n  return itemSize;\n}\n","import {\n  useCallback,\n  useLayoutEffect,\n  useRef,\n  useState,\n  type CSSProperties\n} from \"react\";\nimport { useIsomorphicLayoutEffect } from \"../hooks/useIsomorphicLayoutEffect\";\nimport { useResizeObserver } from \"../hooks/useResizeObserver\";\nimport { useStableCallback } from \"../hooks/useStableCallback\";\nimport type { Align } from \"../types\";\nimport { adjustScrollOffsetForRtl } from \"../utils/adjustScrollOffsetForRtl\";\nimport { shallowCompare } from \"../utils/shallowCompare\";\nimport { getEstimatedSize as getEstimatedSizeUtil } from \"./getEstimatedSize\";\nimport { getOffsetForIndex } from \"./getOffsetForIndex\";\nimport { getStartStopIndices as getStartStopIndicesUtil } from \"./getStartStopIndices\";\nimport type { Direction, SizeFunction } from \"./types\";\nimport { useCachedBounds } from \"./useCachedBounds\";\nimport { useItemSize } from \"./useItemSize\";\n\nexport function useVirtualizer<Props extends object>({\n  containerElement,\n  containerStyle,\n  defaultContainerSize = 0,\n  direction,\n  isRtl = false,\n  itemCount,\n  itemProps,\n  itemSize: itemSizeProp,\n  onResize,\n  overscanCount\n}: {\n  containerElement: HTMLElement | null;\n  containerStyle?: CSSProperties;\n  defaultContainerSize?: number;\n  direction: Direction;\n  isRtl?: boolean;\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | string | SizeFunction<Props>;\n  onResize:\n    | ((\n        size: { height: number; width: number },\n        prevSize: { height: number; width: number }\n      ) => void)\n    | undefined;\n  overscanCount: number;\n}) {\n  const [indices, setIndices] = useState<{\n    startIndexVisible: number;\n    stopIndexVisible: number;\n    startIndexOverscan: number;\n    stopIndexOverscan: number;\n  }>({\n    startIndexVisible: 0,\n    startIndexOverscan: 0,\n    stopIndexVisible: -1,\n    stopIndexOverscan: -1\n  });\n\n  // Guard against temporarily invalid indices that may occur when item count decreases\n  // Cached bounds object will be re-created and a second render will restore things\n  const {\n    startIndexVisible,\n    startIndexOverscan,\n    stopIndexVisible,\n    stopIndexOverscan\n  } = {\n    startIndexVisible: Math.min(itemCount - 1, indices.startIndexVisible),\n    startIndexOverscan: Math.min(itemCount - 1, indices.startIndexOverscan),\n    stopIndexVisible: Math.min(itemCount - 1, indices.stopIndexVisible),\n    stopIndexOverscan: Math.min(itemCount - 1, indices.stopIndexOverscan)\n  };\n\n  const { height = defaultContainerSize, width = defaultContainerSize } =\n    useResizeObserver({\n      defaultHeight:\n        direction === \"vertical\" ? defaultContainerSize : undefined,\n      defaultWidth:\n        direction === \"horizontal\" ? defaultContainerSize : undefined,\n      element: containerElement,\n      mode: direction === \"vertical\" ? \"only-height\" : \"only-width\",\n      style: containerStyle\n    });\n\n  const prevSizeRef = useRef<{ height: number; width: number }>({\n    height: 0,\n    width: 0\n  });\n\n  const containerSize = direction === \"vertical\" ? height : width;\n\n  const itemSize = useItemSize({ containerSize, itemSize: itemSizeProp });\n\n  useLayoutEffect(() => {\n    if (typeof onResize === \"function\") {\n      const prevSize = prevSizeRef.current;\n\n      if (prevSize.height !== height || prevSize.width !== width) {\n        onResize({ height, width }, { ...prevSize });\n\n        prevSize.height = height;\n        prevSize.width = width;\n      }\n    }\n  }, [height, onResize, width]);\n\n  const cachedBounds = useCachedBounds({\n    itemCount,\n    itemProps,\n    itemSize\n  });\n\n  const getCellBounds = useCallback(\n    (index: number) => cachedBounds.get(index),\n    [cachedBounds]\n  );\n\n  const getEstimatedSize = useCallback(\n    () =>\n      getEstimatedSizeUtil({\n        cachedBounds,\n        itemCount,\n        itemSize\n      }),\n    [cachedBounds, itemCount, itemSize]\n  );\n\n  const getStartStopIndices = useCallback(\n    (scrollOffset: number) => {\n      const containerScrollOffset = adjustScrollOffsetForRtl({\n        containerElement,\n        direction,\n        isRtl,\n        scrollOffset\n      });\n\n      return getStartStopIndicesUtil({\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        itemCount,\n        overscanCount\n      });\n    },\n    [\n      cachedBounds,\n      containerElement,\n      containerSize,\n      direction,\n      isRtl,\n      itemCount,\n      overscanCount\n    ]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    const scrollOffset =\n      (direction === \"vertical\"\n        ? containerElement?.scrollTop\n        : containerElement?.scrollLeft) ?? 0;\n\n    setIndices(getStartStopIndices(scrollOffset));\n  }, [containerElement, direction, getStartStopIndices]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!containerElement) {\n      return;\n    }\n\n    const onScroll = () => {\n      setIndices((prev) => {\n        const { scrollLeft, scrollTop } = containerElement;\n\n        const scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset: direction === \"vertical\" ? scrollTop : scrollLeft\n        });\n\n        const next = getStartStopIndicesUtil({\n          cachedBounds,\n          containerScrollOffset: scrollOffset,\n          containerSize,\n          itemCount,\n          overscanCount\n        });\n\n        if (shallowCompare(next, prev)) {\n          return prev;\n        }\n\n        return next;\n      });\n    };\n\n    containerElement.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      containerElement.removeEventListener(\"scroll\", onScroll);\n    };\n  }, [\n    cachedBounds,\n    containerElement,\n    containerSize,\n    direction,\n    itemCount,\n    overscanCount\n  ]);\n\n  const scrollToIndex = useStableCallback(\n    ({\n      align = \"auto\",\n      containerScrollOffset,\n      index\n    }: {\n      align?: Align;\n      containerScrollOffset: number;\n      index: number;\n    }) => {\n      let scrollOffset = getOffsetForIndex({\n        align,\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        index,\n        itemCount,\n        itemSize\n      });\n\n      if (containerElement) {\n        scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset\n        });\n\n        if (typeof containerElement.scrollTo !== \"function\") {\n          // Special case for environments like jsdom that don't implement scrollTo\n          const next = getStartStopIndices(scrollOffset);\n          if (!shallowCompare(indices, next)) {\n            setIndices(next);\n          }\n        }\n\n        return scrollOffset;\n      }\n    }\n  );\n\n  return {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  };\n}\n","import { useMemo } from \"react\";\n\nexport function useMemoizedObject<Type extends object>(\n  unstableObject: Type\n): Type {\n  return useMemo(() => {\n    return unstableObject;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(unstableObject));\n}\n","import type { CSSProperties } from \"react\";\nimport { shallowCompare } from \"./shallowCompare\";\n\n// Custom comparison function for React.memo()\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://react.dev/reference/react/memo#memo\nexport function arePropsEqual(\n  prevProps: { ariaAttributes: object; style: CSSProperties },\n  nextProps: { ariaAttributes: object; style: CSSProperties }\n): boolean {\n  const {\n    ariaAttributes: prevAriaAttributes,\n    style: prevStyle,\n    ...prevRest\n  } = prevProps;\n  const {\n    ariaAttributes: nextAriaAttributes,\n    style: nextStyle,\n    ...nextRest\n  } = nextProps;\n\n  return (\n    shallowCompare(prevAriaAttributes, nextAriaAttributes) &&\n    shallowCompare(prevStyle, nextStyle) &&\n    shallowCompare(prevRest, nextRest)\n  );\n}\n","import {\n  createElement,\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactNode\n} from \"react\";\nimport { useIsRtl } from \"../../core/useIsRtl\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align, TagNames } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport type { GridProps } from \"./types\";\n\nexport function Grid<\n  CellProps extends object,\n  TagName extends TagNames = \"div\"\n>({\n  cellComponent: CellComponentProp,\n  cellProps: cellPropsUnstable,\n  children,\n  className,\n  columnCount,\n  columnWidth,\n  defaultHeight = 0,\n  defaultWidth = 0,\n  dir,\n  gridRef,\n  onCellsRendered,\n  onResize,\n  overscanCount = 3,\n  rowCount,\n  rowHeight,\n  style,\n  tagName = \"div\" as TagName,\n  ...rest\n}: GridProps<CellProps, TagName>) {\n  const cellProps = useMemoizedObject(cellPropsUnstable);\n  const CellComponent = useMemo(\n    () => memo(CellComponentProp, arePropsEqual),\n    [CellComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const isRtl = useIsRtl(element, dir);\n\n  const {\n    getCellBounds: getColumnBounds,\n    getEstimatedSize: getEstimatedWidth,\n    startIndexOverscan: columnStartIndexOverscan,\n    startIndexVisible: columnStartIndexVisible,\n    scrollToIndex: scrollToColumnIndex,\n    stopIndexOverscan: columnStopIndexOverscan,\n    stopIndexVisible: columnStopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultWidth,\n    direction: \"horizontal\",\n    isRtl,\n    itemCount: columnCount,\n    itemProps: cellProps,\n    itemSize: columnWidth,\n    onResize,\n    overscanCount\n  });\n\n  const {\n    getCellBounds: getRowBounds,\n    getEstimatedSize: getEstimatedHeight,\n    startIndexOverscan: rowStartIndexOverscan,\n    startIndexVisible: rowStartIndexVisible,\n    scrollToIndex: scrollToRowIndex,\n    stopIndexOverscan: rowStopIndexOverscan,\n    stopIndexVisible: rowStopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: cellProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    gridRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToCell({\n        behavior = \"auto\",\n        columnAlign = \"auto\",\n        columnIndex,\n        rowAlign = \"auto\",\n        rowIndex\n      }: {\n        behavior?: ScrollBehavior;\n        columnAlign?: Align;\n        columnIndex: number;\n        rowAlign?: Align;\n        rowIndex: number;\n      }) {\n        const left = scrollToColumnIndex({\n          align: columnAlign,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index: columnIndex\n        });\n        const top = scrollToRowIndex({\n          align: rowAlign,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index: rowIndex\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            left,\n            top\n          });\n        }\n      },\n\n      scrollToColumn({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const left = scrollToColumnIndex({\n          align,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            left\n          });\n        }\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const top = scrollToRowIndex({\n          align,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            top\n          });\n        }\n      }\n    }),\n    [element, scrollToColumnIndex, scrollToRowIndex]\n  );\n\n  useEffect(() => {\n    if (\n      columnStartIndexOverscan >= 0 &&\n      columnStopIndexOverscan >= 0 &&\n      rowStartIndexOverscan >= 0 &&\n      rowStopIndexOverscan >= 0 &&\n      onCellsRendered\n    ) {\n      onCellsRendered(\n        {\n          columnStartIndex: columnStartIndexVisible,\n          columnStopIndex: columnStopIndexVisible,\n          rowStartIndex: rowStartIndexVisible,\n          rowStopIndex: rowStopIndexVisible\n        },\n        {\n          columnStartIndex: columnStartIndexOverscan,\n          columnStopIndex: columnStopIndexOverscan,\n          rowStartIndex: rowStartIndexOverscan,\n          rowStopIndex: rowStopIndexOverscan\n        }\n      );\n    }\n  }, [\n    onCellsRendered,\n    columnStartIndexOverscan,\n    columnStartIndexVisible,\n    columnStopIndexOverscan,\n    columnStopIndexVisible,\n    rowStartIndexOverscan,\n    rowStartIndexVisible,\n    rowStopIndexOverscan,\n    rowStopIndexVisible\n  ]);\n\n  const cells = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (columnCount > 0 && rowCount > 0) {\n      for (\n        let rowIndex = rowStartIndexOverscan;\n        rowIndex <= rowStopIndexOverscan;\n        rowIndex++\n      ) {\n        const rowBounds = getRowBounds(rowIndex);\n\n        const columns: ReactNode[] = [];\n\n        for (\n          let columnIndex = columnStartIndexOverscan;\n          columnIndex <= columnStopIndexOverscan;\n          columnIndex++\n        ) {\n          const columnBounds = getColumnBounds(columnIndex);\n\n          columns.push(\n            <CellComponent\n              {...(cellProps as CellProps)}\n              ariaAttributes={{\n                \"aria-colindex\": columnIndex + 1,\n                role: \"gridcell\"\n              }}\n              columnIndex={columnIndex}\n              key={columnIndex}\n              rowIndex={rowIndex}\n              style={{\n                position: \"absolute\",\n                left: isRtl ? undefined : 0,\n                right: isRtl ? 0 : undefined,\n                transform: `translate(${isRtl ? -columnBounds.scrollOffset : columnBounds.scrollOffset}px, ${rowBounds.scrollOffset}px)`,\n                height: rowBounds.size,\n                width: columnBounds.size\n              }}\n            />\n          );\n        }\n\n        children.push(\n          <div key={rowIndex} role=\"row\" aria-rowindex={rowIndex + 1}>\n            {columns}\n          </div>\n        );\n      }\n    }\n    return children;\n  }, [\n    CellComponent,\n    cellProps,\n    columnCount,\n    columnStartIndexOverscan,\n    columnStopIndexOverscan,\n    getColumnBounds,\n    getRowBounds,\n    isRtl,\n    rowCount,\n    rowStartIndexOverscan,\n    rowStopIndexOverscan\n  ]);\n\n  const sizingElement = (\n    <div\n      aria-hidden\n      style={{\n        height: getEstimatedHeight(),\n        width: getEstimatedWidth(),\n        zIndex: -1\n      }}\n    ></div>\n  );\n\n  return createElement(\n    tagName,\n    {\n      \"aria-colcount\": columnCount,\n      \"aria-rowcount\": rowCount,\n      role: \"grid\",\n      ...rest,\n      className,\n      dir,\n      ref: setElement,\n      style: {\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100%\",\n        maxHeight: \"100%\",\n        maxWidth: \"100%\",\n        flexGrow: 1,\n        overflow: \"auto\",\n        ...style\n      }\n    },\n    cells,\n    children,\n    sizingElement\n  );\n}\n","import { useState } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Grid component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useGridCallbackRef =\n  useState as typeof useState<GridImperativeAPI | null>;\n","import { useRef } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Grid component.\n */\nexport const useGridRef = useRef as typeof useRef<GridImperativeAPI>;\n","import type { DynamicRowHeight } from \"./types\";\n\nexport function isDynamicRowHeight(value: unknown): value is DynamicRowHeight {\n  return (\n    value != null &&\n    typeof value === \"object\" &&\n    \"getAverageRowHeight\" in value &&\n    typeof value.getAverageRowHeight === \"function\"\n  );\n}\n","import {\n  createElement,\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactNode\n} from \"react\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align, TagNames } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport { isDynamicRowHeight as isDynamicRowHeightUtil } from \"./isDynamicRowHeight\";\nimport type { ListProps } from \"./types\";\n\nexport const DATA_ATTRIBUTE_LIST_INDEX = \"data-react-window-index\";\n\nexport function List<\n  RowProps extends object,\n  TagName extends TagNames = \"div\"\n>({\n  children,\n  className,\n  defaultHeight = 0,\n  listRef,\n  onResize,\n  onRowsRendered,\n  overscanCount = 3,\n  rowComponent: RowComponentProp,\n  rowCount,\n  rowHeight: rowHeightProp,\n  rowProps: rowPropsUnstable,\n  tagName = \"div\" as TagName,\n  style,\n  ...rest\n}: ListProps<RowProps, TagName>) {\n  const rowProps = useMemoizedObject(rowPropsUnstable);\n  const RowComponent = useMemo(\n    () => memo(RowComponentProp, arePropsEqual),\n    [RowComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const isDynamicRowHeight = isDynamicRowHeightUtil(rowHeightProp);\n\n  const rowHeight = useMemo(() => {\n    if (isDynamicRowHeight) {\n      return (index: number) => {\n        return (\n          rowHeightProp.getRowHeight(index) ??\n          rowHeightProp.getAverageRowHeight()\n        );\n      };\n    }\n\n    return rowHeightProp;\n  }, [isDynamicRowHeight, rowHeightProp]);\n\n  const {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: rowProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    listRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const top = scrollToIndex({\n          align,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            top\n          });\n        }\n      }\n    }),\n    [element, scrollToIndex]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    const rows = Array.from(element.children).filter((item, index) => {\n      if (item.hasAttribute(\"aria-hidden\")) {\n        // Ignore sizing element\n        return false;\n      }\n\n      const attribute = `${startIndexOverscan + index}`;\n      item.setAttribute(DATA_ATTRIBUTE_LIST_INDEX, attribute);\n\n      return true;\n    });\n\n    if (isDynamicRowHeight) {\n      return rowHeightProp.observeRowElements(rows);\n    }\n  }, [\n    element,\n    isDynamicRowHeight,\n    rowHeightProp,\n    startIndexOverscan,\n    stopIndexOverscan\n  ]);\n\n  useEffect(() => {\n    if (startIndexOverscan >= 0 && stopIndexOverscan >= 0 && onRowsRendered) {\n      onRowsRendered(\n        {\n          startIndex: startIndexVisible,\n          stopIndex: stopIndexVisible\n        },\n        {\n          startIndex: startIndexOverscan,\n          stopIndex: stopIndexOverscan\n        }\n      );\n    }\n  }, [\n    onRowsRendered,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  ]);\n\n  const rows = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (rowCount > 0) {\n      for (\n        let index = startIndexOverscan;\n        index <= stopIndexOverscan;\n        index++\n      ) {\n        const bounds = getCellBounds(index);\n\n        children.push(\n          <RowComponent\n            {...(rowProps as RowProps)}\n            ariaAttributes={{\n              \"aria-posinset\": index + 1,\n              \"aria-setsize\": rowCount,\n              role: \"listitem\"\n            }}\n            key={index}\n            index={index}\n            style={{\n              position: \"absolute\",\n              left: 0,\n              transform: `translateY(${bounds.scrollOffset}px)`,\n              // In case of dynamic row heights, don't specify a height style\n              // otherwise a default/estimated height would mask the actual height\n              height: isDynamicRowHeight ? undefined : bounds.size,\n              width: \"100%\"\n            }}\n          />\n        );\n      }\n    }\n    return children;\n  }, [\n    RowComponent,\n    getCellBounds,\n    isDynamicRowHeight,\n    rowCount,\n    rowProps,\n    startIndexOverscan,\n    stopIndexOverscan\n  ]);\n\n  const sizingElement = (\n    <div\n      aria-hidden\n      style={{\n        height: getEstimatedSize(),\n        width: \"100%\",\n        zIndex: -1\n      }}\n    ></div>\n  );\n\n  return createElement(\n    tagName,\n    {\n      role: \"list\",\n      ...rest,\n      className,\n      ref: setElement,\n      style: {\n        position: \"relative\",\n        maxHeight: \"100%\",\n        flexGrow: 1,\n        overflowY: \"auto\",\n        ...style\n      }\n    },\n    rows,\n    children,\n    sizingElement\n  );\n}\n","import { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { assert } from \"../../utils/assert\";\nimport { DATA_ATTRIBUTE_LIST_INDEX } from \"./List\";\nimport type { DynamicRowHeight } from \"./types\";\n\nexport function useDynamicRowHeight({\n  defaultRowHeight,\n  key\n}: {\n  defaultRowHeight: number;\n  key?: string | number;\n}) {\n  const [state, setState] = useState<{\n    key: string | number | undefined;\n    map: Map<number, number>;\n  }>({\n    key,\n    map: new Map()\n  });\n\n  if (state.key !== key) {\n    setState({\n      key,\n      map: new Map()\n    });\n  }\n\n  const { map } = state;\n\n  const getAverageRowHeight = useCallback(() => {\n    let totalHeight = 0;\n\n    map.forEach((height) => {\n      totalHeight += height;\n    });\n\n    if (totalHeight === 0) {\n      return defaultRowHeight;\n    }\n\n    return totalHeight / map.size;\n  }, [defaultRowHeight, map]);\n\n  const getRowHeight = useCallback(\n    (index: number) => {\n      return map.get(index);\n    },\n    [map]\n  );\n\n  const setRowHeight = useCallback((index: number, size: number) => {\n    setState((prevState) => {\n      if (prevState.map.get(index) === size) {\n        return prevState;\n      }\n\n      const clonedMap = new Map(prevState.map);\n      clonedMap.set(index, size);\n\n      return {\n        ...prevState,\n        map: clonedMap\n      };\n    });\n  }, []);\n\n  const resizeObserverCallback = useStableCallback(\n    (entries: ResizeObserverEntry[]) => {\n      if (entries.length === 0) {\n        return;\n      }\n\n      entries.forEach((entry) => {\n        const { borderBoxSize, target } = entry;\n\n        const attribute = target.getAttribute(DATA_ATTRIBUTE_LIST_INDEX);\n        assert(\n          attribute !== null,\n          `Invalid ${DATA_ATTRIBUTE_LIST_INDEX} attribute value`\n        );\n\n        const index = parseInt(attribute);\n\n        const { blockSize: height } = borderBoxSize[0];\n        if (!height) {\n          // Ignore heights that have not yet been measured (e.g. <img> elements that have not yet loaded)\n          return;\n        }\n\n        setRowHeight(index, height);\n      });\n    }\n  );\n\n  const [resizeObserver] = useState(\n    () => new ResizeObserver(resizeObserverCallback)\n  );\n\n  useEffect(() => {\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [resizeObserver]);\n\n  const observeRowElements = useCallback(\n    (elements: Element[] | NodeListOf<Element>) => {\n      elements.forEach((element) => resizeObserver.observe(element));\n      return () => {\n        elements.forEach((element) => resizeObserver.unobserve(element));\n      };\n    },\n    [resizeObserver]\n  );\n\n  return useMemo<DynamicRowHeight>(\n    () => ({\n      getAverageRowHeight,\n      getRowHeight,\n      setRowHeight,\n      observeRowElements\n    }),\n    [getAverageRowHeight, getRowHeight, setRowHeight, observeRowElements]\n  );\n}\n","import { useState } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the List component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useListCallbackRef =\n  useState as typeof useState<ListImperativeAPI | null>;\n","import { useRef } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the List component.\n */\nexport const useListRef = useRef as typeof useRef<ListImperativeAPI>;\n","let size: number = -1;\n\nexport function getScrollbarSize(recalculate: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement(\"div\");\n    const style = div.style;\n    style.width = \"50px\";\n    style.height = \"50px\";\n    style.overflow = \"scroll\";\n\n    document.body.appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nexport function setScrollbarSizeForTests(value: number) {\n  size = value;\n}\n"],"names":["isRtl","element","currentElement","useIsRtl","dir","value","setValue","useState","useLayoutEffect","useIsomorphicLayoutEffect","useEffect","parseNumericStyleValue","useResizeObserver","box","defaultHeight","defaultWidth","disabledProp","mode","style","styleHeight","styleWidth","useMemo","state","setState","disabled","resizeObserver","entries","entry","contentRect","target","prevState","useStableCallback","fn","ref","useRef","useCallback","args","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","outerStyle","innerDiv","innerStyle","adjustScrollOffsetForRtl","containerElement","direction","scrollOffset","clientWidth","scrollLeft","scrollWidth","assert","expectedCondition","message","shallowCompare","a","b","key","getEstimatedSize","cachedBounds","itemCount","itemSize","bounds","averageItemSize","getOffsetForIndex","align","index","containerScrollOffset","containerSize","estimatedTotalSize","maxOffset","minOffset","getStartStopIndices","overscanCount","maxIndex","startIndexVisible","stopIndexVisible","startIndexOverscan","stopIndexOverscan","currentIndex","createCachedBounds","itemProps","cache","size","previousRowBounds","useCachedBounds","useItemSize","itemSizeProp","useVirtualizer","containerStyle","defaultContainerSize","onResize","indices","setIndices","height","width","prevSizeRef","prevSize","getCellBounds","getEstimatedSizeUtil","getStartStopIndicesUtil","onScroll","prev","scrollTop","next","scrollToIndex","useMemoizedObject","unstableObject","arePropsEqual","prevProps","nextProps","prevAriaAttributes","prevStyle","prevRest","nextAriaAttributes","nextStyle","nextRest","Grid","CellComponentProp","cellPropsUnstable","children","className","columnCount","columnWidth","gridRef","onCellsRendered","rowCount","rowHeight","tagName","rest","cellProps","CellComponent","memo","setElement","getColumnBounds","getEstimatedWidth","columnStartIndexOverscan","columnStartIndexVisible","scrollToColumnIndex","columnStopIndexOverscan","columnStopIndexVisible","getRowBounds","getEstimatedHeight","rowStartIndexOverscan","rowStartIndexVisible","scrollToRowIndex","rowStopIndexOverscan","rowStopIndexVisible","useImperativeHandle","behavior","columnAlign","columnIndex","rowAlign","rowIndex","left","top","cells","rowBounds","columns","columnBounds","createElement","jsx","sizingElement","useGridCallbackRef","useGridRef","isDynamicRowHeight","DATA_ATTRIBUTE_LIST_INDEX","List","listRef","onRowsRendered","RowComponentProp","rowHeightProp","rowPropsUnstable","rowProps","RowComponent","isDynamicRowHeightUtil","rows","item","attribute","useDynamicRowHeight","defaultRowHeight","map","getAverageRowHeight","totalHeight","getRowHeight","setRowHeight","clonedMap","resizeObserverCallback","borderBoxSize","observeRowElements","elements","useListCallbackRef","useListRef","getScrollbarSize","div"],"mappings":"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"}