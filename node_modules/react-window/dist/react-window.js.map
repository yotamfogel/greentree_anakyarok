{"version":3,"file":"react-window.js","sources":["../lib/utils/isRtl.ts","../lib/core/useIsRtl.ts","../lib/hooks/useIsomorphicLayoutEffect.ts","../lib/utils/parseNumericStyleValue.ts","../lib/hooks/useResizeObserver.ts","../lib/hooks/useStableCallback.ts","../lib/utils/getRTLOffsetType.ts","../lib/utils/adjustScrollOffsetForRtl.ts","../lib/utils/assert.ts","../lib/utils/shallowCompare.ts","../lib/core/getEstimatedSize.ts","../lib/core/getOffsetForIndex.ts","../lib/core/getStartStopIndices.ts","../lib/core/createCachedBounds.ts","../lib/core/useCachedBounds.ts","../lib/core/useItemSize.ts","../lib/core/useVirtualizer.ts","../lib/hooks/useMemoizedObject.ts","../lib/utils/arePropsEqual.ts","../lib/components/grid/Grid.tsx","../lib/components/grid/useGridCallbackRef.ts","../lib/components/grid/useGridRef.ts","../lib/components/list/isDynamicRowHeight.ts","../lib/components/list/List.tsx","../lib/components/list/useDynamicRowHeight.ts","../lib/components/list/useListCallbackRef.ts","../lib/components/list/useListRef.ts","../lib/utils/getScrollbarSize.ts"],"sourcesContent":["export function isRtl(element: HTMLElement) {\n  let currentElement: HTMLElement | null = element;\n  while (currentElement) {\n    if (currentElement.dir) {\n      return currentElement.dir === \"rtl\";\n    }\n\n    currentElement = currentElement.parentElement;\n  }\n\n  return false;\n}\n","import { useLayoutEffect, useState, type HTMLAttributes } from \"react\";\nimport { isRtl } from \"../utils/isRtl\";\n\nexport function useIsRtl(\n  element: HTMLElement | null,\n  dir: HTMLAttributes<HTMLElement>[\"dir\"]\n) {\n  const [value, setValue] = useState(dir === \"rtl\");\n\n  useLayoutEffect(() => {\n    if (element) {\n      if (!dir) {\n        setValue(isRtl(element));\n      }\n    }\n  }, [dir, element]);\n\n  return value;\n}\n","import { useEffect, useLayoutEffect } from \"react\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import type { CSSProperties } from \"react\";\n\nexport function parseNumericStyleValue(\n  value: CSSProperties[\"height\"]\n): number | undefined {\n  if (value !== undefined) {\n    switch (typeof value) {\n      case \"number\": {\n        return value;\n      }\n      case \"string\": {\n        if (value.endsWith(\"px\")) {\n          return parseFloat(value);\n        }\n        break;\n      }\n    }\n  }\n}\n","import { useMemo, useState, type CSSProperties } from \"react\";\nimport { parseNumericStyleValue } from \"../utils/parseNumericStyleValue\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\nexport function useResizeObserver({\n  box,\n  defaultHeight,\n  defaultWidth,\n  disabled: disabledProp,\n  element,\n  mode,\n  style\n}: {\n  box?: ResizeObserverBoxOptions;\n  defaultHeight?: number;\n  defaultWidth?: number;\n  disabled?: boolean;\n  element: HTMLElement | null;\n  mode?: \"only-height\" | \"only-width\";\n  style: CSSProperties | undefined;\n}) {\n  const { styleHeight, styleWidth } = useMemo(\n    () => ({\n      styleHeight: parseNumericStyleValue(style?.height),\n      styleWidth: parseNumericStyleValue(style?.width)\n    }),\n    [style?.height, style?.width]\n  );\n\n  const [state, setState] = useState<{\n    height: number | undefined;\n    width: number | undefined;\n  }>({\n    height: defaultHeight,\n    width: defaultWidth\n  });\n\n  const disabled =\n    disabledProp ||\n    (mode === \"only-height\" && styleHeight !== undefined) ||\n    (mode === \"only-width\" && styleWidth !== undefined) ||\n    (styleHeight !== undefined && styleWidth !== undefined);\n\n  useIsomorphicLayoutEffect(() => {\n    if (element === null || disabled) {\n      return;\n    }\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { contentRect, target } = entry;\n        if (element === target) {\n          setState((prevState) => {\n            if (\n              prevState.height === contentRect.height &&\n              prevState.width === contentRect.width\n            ) {\n              return prevState;\n            }\n\n            return {\n              height: contentRect.height,\n              width: contentRect.width\n            };\n          });\n        }\n      }\n    });\n    resizeObserver.observe(element, { box });\n\n    return () => {\n      resizeObserver?.unobserve(element);\n    };\n  }, [box, disabled, element, styleHeight, styleWidth]);\n\n  return useMemo(\n    () => ({\n      height: styleHeight ?? state.height,\n      width: styleWidth ?? state.width\n    }),\n    [state, styleHeight, styleWidth]\n  );\n}\n","import { useCallback, useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\n// Forked from useEventCallback (usehooks-ts)\nexport function useStableCallback<Args, Return>(\n  fn: (args: Args) => Return\n): (args: Args) => Return {\n  const ref = useRef<typeof fn>(() => {\n    throw new Error(\"Cannot call an event handler while rendering.\");\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback((args: Args) => ref.current?.(args), [ref]) as (\n    args: Args\n  ) => Return;\n}\n","export type RTLOffsetType =\n  | \"negative\"\n  | \"positive-descending\"\n  | \"positive-ascending\";\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n\n    outerDiv.appendChild(innerDiv);\n\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = \"positive-descending\";\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = \"negative\";\n      } else {\n        cachedRTLResult = \"positive-ascending\";\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","import type { Direction } from \"../core/types\";\nimport { getRTLOffsetType } from \"./getRTLOffsetType\";\n\nexport function adjustScrollOffsetForRtl({\n  containerElement,\n  direction,\n  isRtl,\n  scrollOffset\n}: {\n  containerElement: HTMLElement | null;\n  direction: Direction;\n  isRtl: boolean;\n  scrollOffset: number;\n}) {\n  // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n  // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n  // So we need to determine which browser behavior we're dealing with, and mimic it.\n  if (direction === \"horizontal\") {\n    if (isRtl) {\n      switch (getRTLOffsetType()) {\n        case \"negative\": {\n          return -scrollOffset;\n        }\n        case \"positive-descending\": {\n          if (containerElement) {\n            const { clientWidth, scrollLeft, scrollWidth } = containerElement;\n            return scrollWidth - clientWidth - scrollLeft;\n          }\n          break;\n        }\n      }\n    }\n  }\n  return scrollOffset;\n}\n","export function assert(\n  expectedCondition: unknown,\n  message: string = \"Assertion error\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n\n    throw Error(message);\n  }\n}\n","import { assert } from \"./assert\";\n\nexport function shallowCompare<Type extends object>(\n  a: Type | undefined,\n  b: Type | undefined\n) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!!a !== !!b) {\n    return false;\n  }\n\n  assert(a !== undefined);\n  assert(b !== undefined);\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (!Object.is(b[key], a[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { CachedBounds, SizeFunction } from \"./types\";\nimport { assert } from \"../utils/assert\";\n\nexport function getEstimatedSize<Props extends object>({\n  cachedBounds,\n  itemCount,\n  itemSize\n}: {\n  cachedBounds: CachedBounds;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n}) {\n  if (itemCount === 0) {\n    return 0;\n  } else if (typeof itemSize === \"number\") {\n    return itemCount * itemSize;\n  } else {\n    const bounds = cachedBounds.get(\n      cachedBounds.size === 0 ? 0 : cachedBounds.size - 1\n    );\n    assert(bounds !== undefined, \"Unexpected bounds cache miss\");\n\n    const averageItemSize =\n      (bounds.scrollOffset + bounds.size) / cachedBounds.size;\n\n    return itemCount * averageItemSize;\n  }\n}\n","import type { Align } from \"../types\";\nimport { getEstimatedSize } from \"./getEstimatedSize\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function getOffsetForIndex<Props extends object>({\n  align,\n  cachedBounds,\n  index,\n  itemCount,\n  itemSize,\n  containerScrollOffset,\n  containerSize\n}: {\n  align: Align;\n  cachedBounds: CachedBounds;\n  index: number;\n  itemCount: number;\n  itemSize: number | SizeFunction<Props>;\n  containerScrollOffset: number;\n  containerSize: number;\n}) {\n  const estimatedTotalSize = getEstimatedSize({\n    cachedBounds,\n    itemCount,\n    itemSize\n  });\n\n  const bounds = cachedBounds.get(index);\n  const maxOffset = Math.max(\n    0,\n    Math.min(estimatedTotalSize - containerSize, bounds.scrollOffset)\n  );\n  const minOffset = Math.max(\n    0,\n    bounds.scrollOffset - containerSize + bounds.size\n  );\n\n  if (align === \"smart\") {\n    if (\n      containerScrollOffset >= minOffset &&\n      containerScrollOffset <= maxOffset\n    ) {\n      align = \"auto\";\n    } else {\n      align = \"center\";\n    }\n  }\n\n  switch (align) {\n    case \"start\": {\n      return maxOffset;\n    }\n    case \"end\": {\n      return minOffset;\n    }\n    case \"center\": {\n      if (bounds.scrollOffset <= containerSize / 2) {\n        // Too near the beginning to center-align\n        return 0;\n      } else if (\n        bounds.scrollOffset + bounds.size / 2 >=\n        estimatedTotalSize - containerSize / 2\n      ) {\n        // Too near the end to center-align\n        return estimatedTotalSize - containerSize;\n      } else {\n        return bounds.scrollOffset + bounds.size / 2 - containerSize / 2;\n      }\n    }\n    case \"auto\":\n    default: {\n      if (\n        containerScrollOffset >= minOffset &&\n        containerScrollOffset <= maxOffset\n      ) {\n        return containerScrollOffset;\n      } else if (containerScrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n}\n","import type { CachedBounds } from \"./types\";\n\nexport function getStartStopIndices({\n  cachedBounds,\n  containerScrollOffset,\n  containerSize,\n  itemCount,\n  overscanCount\n}: {\n  cachedBounds: CachedBounds;\n  containerScrollOffset: number;\n  containerSize: number;\n  itemCount: number;\n  overscanCount: number;\n}): {\n  startIndexVisible: number;\n  stopIndexVisible: number;\n  startIndexOverscan: number;\n  stopIndexOverscan: number;\n} {\n  const maxIndex = itemCount - 1;\n\n  let startIndexVisible = 0;\n  let stopIndexVisible = -1;\n  let startIndexOverscan = 0;\n  let stopIndexOverscan = -1;\n  let currentIndex = 0;\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (bounds.scrollOffset + bounds.size > containerScrollOffset) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  startIndexVisible = currentIndex;\n  startIndexOverscan = Math.max(0, startIndexVisible - overscanCount);\n\n  while (currentIndex < maxIndex) {\n    const bounds = cachedBounds.get(currentIndex);\n\n    if (\n      bounds.scrollOffset + bounds.size >=\n      containerScrollOffset + containerSize\n    ) {\n      break;\n    }\n\n    currentIndex++;\n  }\n\n  stopIndexVisible = Math.min(maxIndex, currentIndex);\n  stopIndexOverscan = Math.min(itemCount - 1, stopIndexVisible + overscanCount);\n\n  if (startIndexVisible < 0) {\n    startIndexVisible = 0;\n    stopIndexVisible = -1;\n    startIndexOverscan = 0;\n    stopIndexOverscan = -1;\n  }\n\n  return {\n    startIndexVisible,\n    stopIndexVisible,\n    startIndexOverscan,\n    stopIndexOverscan\n  };\n}\n","import { assert } from \"../utils/assert\";\nimport type { Bounds, CachedBounds, SizeFunction } from \"./types\";\n\nexport function createCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  const cache = new Map<number, Bounds>();\n\n  return {\n    get(index: number) {\n      assert(index < itemCount, `Invalid index ${index}`);\n\n      while (cache.size - 1 < index) {\n        const currentIndex = cache.size;\n\n        let size: number;\n        switch (typeof itemSize) {\n          case \"function\": {\n            size = itemSize(currentIndex, itemProps);\n            break;\n          }\n          case \"number\": {\n            size = itemSize;\n            break;\n          }\n        }\n\n        if (currentIndex === 0) {\n          cache.set(currentIndex, {\n            size,\n            scrollOffset: 0\n          });\n        } else {\n          const previousRowBounds = cache.get(currentIndex - 1);\n          assert(\n            previousRowBounds !== undefined,\n            `Unexpected bounds cache miss for index ${index}`\n          );\n\n          cache.set(currentIndex, {\n            scrollOffset:\n              previousRowBounds.scrollOffset + previousRowBounds.size,\n            size\n          });\n        }\n      }\n\n      const bounds = cache.get(index);\n      assert(\n        bounds !== undefined,\n        `Unexpected bounds cache miss for index ${index}`\n      );\n\n      return bounds;\n    },\n    set(index: number, bounds: Bounds) {\n      cache.set(index, bounds);\n    },\n    get size() {\n      return cache.size;\n    }\n  };\n}\n","import { useMemo } from \"react\";\nimport { createCachedBounds } from \"./createCachedBounds\";\nimport type { CachedBounds, SizeFunction } from \"./types\";\n\nexport function useCachedBounds<Props extends object>({\n  itemCount,\n  itemProps,\n  itemSize\n}: {\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | SizeFunction<Props>;\n}): CachedBounds {\n  return useMemo(\n    () =>\n      createCachedBounds({\n        itemCount,\n        itemProps,\n        itemSize\n      }),\n    [itemCount, itemProps, itemSize]\n  );\n}\n","import { assert } from \"../utils/assert\";\nimport type { SizeFunction } from \"./types\";\n\nexport function useItemSize<Props extends object>({\n  containerSize,\n  itemSize: itemSizeProp\n}: {\n  containerSize: number;\n  itemSize: number | string | SizeFunction<Props>;\n}) {\n  let itemSize: number | SizeFunction<Props>;\n  switch (typeof itemSizeProp) {\n    case \"string\": {\n      assert(\n        itemSizeProp.endsWith(\"%\"),\n        `Invalid item size: \"${itemSizeProp}\"; string values must be percentages (e.g. \"100%\")`\n      );\n      assert(\n        containerSize !== undefined,\n        \"Container size must be defined if a percentage item size is specified\"\n      );\n\n      itemSize = (containerSize * parseInt(itemSizeProp)) / 100;\n      break;\n    }\n    default: {\n      itemSize = itemSizeProp;\n      break;\n    }\n  }\n\n  return itemSize;\n}\n","import {\n  useCallback,\n  useLayoutEffect,\n  useRef,\n  useState,\n  type CSSProperties\n} from \"react\";\nimport { useIsomorphicLayoutEffect } from \"../hooks/useIsomorphicLayoutEffect\";\nimport { useResizeObserver } from \"../hooks/useResizeObserver\";\nimport { useStableCallback } from \"../hooks/useStableCallback\";\nimport type { Align } from \"../types\";\nimport { adjustScrollOffsetForRtl } from \"../utils/adjustScrollOffsetForRtl\";\nimport { shallowCompare } from \"../utils/shallowCompare\";\nimport { getEstimatedSize as getEstimatedSizeUtil } from \"./getEstimatedSize\";\nimport { getOffsetForIndex } from \"./getOffsetForIndex\";\nimport { getStartStopIndices as getStartStopIndicesUtil } from \"./getStartStopIndices\";\nimport type { Direction, SizeFunction } from \"./types\";\nimport { useCachedBounds } from \"./useCachedBounds\";\nimport { useItemSize } from \"./useItemSize\";\n\nexport function useVirtualizer<Props extends object>({\n  containerElement,\n  containerStyle,\n  defaultContainerSize = 0,\n  direction,\n  isRtl = false,\n  itemCount,\n  itemProps,\n  itemSize: itemSizeProp,\n  onResize,\n  overscanCount\n}: {\n  containerElement: HTMLElement | null;\n  containerStyle?: CSSProperties;\n  defaultContainerSize?: number;\n  direction: Direction;\n  isRtl?: boolean;\n  itemCount: number;\n  itemProps: Props;\n  itemSize: number | string | SizeFunction<Props>;\n  onResize:\n    | ((\n        size: { height: number; width: number },\n        prevSize: { height: number; width: number }\n      ) => void)\n    | undefined;\n  overscanCount: number;\n}) {\n  const [indices, setIndices] = useState<{\n    startIndexVisible: number;\n    stopIndexVisible: number;\n    startIndexOverscan: number;\n    stopIndexOverscan: number;\n  }>({\n    startIndexVisible: 0,\n    startIndexOverscan: 0,\n    stopIndexVisible: -1,\n    stopIndexOverscan: -1\n  });\n\n  // Guard against temporarily invalid indices that may occur when item count decreases\n  // Cached bounds object will be re-created and a second render will restore things\n  const {\n    startIndexVisible,\n    startIndexOverscan,\n    stopIndexVisible,\n    stopIndexOverscan\n  } = {\n    startIndexVisible: Math.min(itemCount - 1, indices.startIndexVisible),\n    startIndexOverscan: Math.min(itemCount - 1, indices.startIndexOverscan),\n    stopIndexVisible: Math.min(itemCount - 1, indices.stopIndexVisible),\n    stopIndexOverscan: Math.min(itemCount - 1, indices.stopIndexOverscan)\n  };\n\n  const { height = defaultContainerSize, width = defaultContainerSize } =\n    useResizeObserver({\n      defaultHeight:\n        direction === \"vertical\" ? defaultContainerSize : undefined,\n      defaultWidth:\n        direction === \"horizontal\" ? defaultContainerSize : undefined,\n      element: containerElement,\n      mode: direction === \"vertical\" ? \"only-height\" : \"only-width\",\n      style: containerStyle\n    });\n\n  const prevSizeRef = useRef<{ height: number; width: number }>({\n    height: 0,\n    width: 0\n  });\n\n  const containerSize = direction === \"vertical\" ? height : width;\n\n  const itemSize = useItemSize({ containerSize, itemSize: itemSizeProp });\n\n  useLayoutEffect(() => {\n    if (typeof onResize === \"function\") {\n      const prevSize = prevSizeRef.current;\n\n      if (prevSize.height !== height || prevSize.width !== width) {\n        onResize({ height, width }, { ...prevSize });\n\n        prevSize.height = height;\n        prevSize.width = width;\n      }\n    }\n  }, [height, onResize, width]);\n\n  const cachedBounds = useCachedBounds({\n    itemCount,\n    itemProps,\n    itemSize\n  });\n\n  const getCellBounds = useCallback(\n    (index: number) => cachedBounds.get(index),\n    [cachedBounds]\n  );\n\n  const getEstimatedSize = useCallback(\n    () =>\n      getEstimatedSizeUtil({\n        cachedBounds,\n        itemCount,\n        itemSize\n      }),\n    [cachedBounds, itemCount, itemSize]\n  );\n\n  const getStartStopIndices = useCallback(\n    (scrollOffset: number) => {\n      const containerScrollOffset = adjustScrollOffsetForRtl({\n        containerElement,\n        direction,\n        isRtl,\n        scrollOffset\n      });\n\n      return getStartStopIndicesUtil({\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        itemCount,\n        overscanCount\n      });\n    },\n    [\n      cachedBounds,\n      containerElement,\n      containerSize,\n      direction,\n      isRtl,\n      itemCount,\n      overscanCount\n    ]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    const scrollOffset =\n      (direction === \"vertical\"\n        ? containerElement?.scrollTop\n        : containerElement?.scrollLeft) ?? 0;\n\n    setIndices(getStartStopIndices(scrollOffset));\n  }, [containerElement, direction, getStartStopIndices]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!containerElement) {\n      return;\n    }\n\n    const onScroll = () => {\n      setIndices((prev) => {\n        const { scrollLeft, scrollTop } = containerElement;\n\n        const scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset: direction === \"vertical\" ? scrollTop : scrollLeft\n        });\n\n        const next = getStartStopIndicesUtil({\n          cachedBounds,\n          containerScrollOffset: scrollOffset,\n          containerSize,\n          itemCount,\n          overscanCount\n        });\n\n        if (shallowCompare(next, prev)) {\n          return prev;\n        }\n\n        return next;\n      });\n    };\n\n    containerElement.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      containerElement.removeEventListener(\"scroll\", onScroll);\n    };\n  }, [\n    cachedBounds,\n    containerElement,\n    containerSize,\n    direction,\n    itemCount,\n    overscanCount\n  ]);\n\n  const scrollToIndex = useStableCallback(\n    ({\n      align = \"auto\",\n      containerScrollOffset,\n      index\n    }: {\n      align?: Align;\n      containerScrollOffset: number;\n      index: number;\n    }) => {\n      let scrollOffset = getOffsetForIndex({\n        align,\n        cachedBounds,\n        containerScrollOffset,\n        containerSize,\n        index,\n        itemCount,\n        itemSize\n      });\n\n      if (containerElement) {\n        scrollOffset = adjustScrollOffsetForRtl({\n          containerElement,\n          direction,\n          isRtl,\n          scrollOffset\n        });\n\n        if (typeof containerElement.scrollTo !== \"function\") {\n          // Special case for environments like jsdom that don't implement scrollTo\n          const next = getStartStopIndices(scrollOffset);\n          if (!shallowCompare(indices, next)) {\n            setIndices(next);\n          }\n        }\n\n        return scrollOffset;\n      }\n    }\n  );\n\n  return {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  };\n}\n","import { useMemo } from \"react\";\n\nexport function useMemoizedObject<Type extends object>(\n  unstableObject: Type\n): Type {\n  return useMemo(() => {\n    return unstableObject;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(unstableObject));\n}\n","import type { CSSProperties } from \"react\";\nimport { shallowCompare } from \"./shallowCompare\";\n\n// Custom comparison function for React.memo()\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://react.dev/reference/react/memo#memo\nexport function arePropsEqual(\n  prevProps: { ariaAttributes: object; style: CSSProperties },\n  nextProps: { ariaAttributes: object; style: CSSProperties }\n): boolean {\n  const {\n    ariaAttributes: prevAriaAttributes,\n    style: prevStyle,\n    ...prevRest\n  } = prevProps;\n  const {\n    ariaAttributes: nextAriaAttributes,\n    style: nextStyle,\n    ...nextRest\n  } = nextProps;\n\n  return (\n    shallowCompare(prevAriaAttributes, nextAriaAttributes) &&\n    shallowCompare(prevStyle, nextStyle) &&\n    shallowCompare(prevRest, nextRest)\n  );\n}\n","import {\n  createElement,\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactNode\n} from \"react\";\nimport { useIsRtl } from \"../../core/useIsRtl\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align, TagNames } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport type { GridProps } from \"./types\";\n\nexport function Grid<\n  CellProps extends object,\n  TagName extends TagNames = \"div\"\n>({\n  cellComponent: CellComponentProp,\n  cellProps: cellPropsUnstable,\n  children,\n  className,\n  columnCount,\n  columnWidth,\n  defaultHeight = 0,\n  defaultWidth = 0,\n  dir,\n  gridRef,\n  onCellsRendered,\n  onResize,\n  overscanCount = 3,\n  rowCount,\n  rowHeight,\n  style,\n  tagName = \"div\" as TagName,\n  ...rest\n}: GridProps<CellProps, TagName>) {\n  const cellProps = useMemoizedObject(cellPropsUnstable);\n  const CellComponent = useMemo(\n    () => memo(CellComponentProp, arePropsEqual),\n    [CellComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const isRtl = useIsRtl(element, dir);\n\n  const {\n    getCellBounds: getColumnBounds,\n    getEstimatedSize: getEstimatedWidth,\n    startIndexOverscan: columnStartIndexOverscan,\n    startIndexVisible: columnStartIndexVisible,\n    scrollToIndex: scrollToColumnIndex,\n    stopIndexOverscan: columnStopIndexOverscan,\n    stopIndexVisible: columnStopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultWidth,\n    direction: \"horizontal\",\n    isRtl,\n    itemCount: columnCount,\n    itemProps: cellProps,\n    itemSize: columnWidth,\n    onResize,\n    overscanCount\n  });\n\n  const {\n    getCellBounds: getRowBounds,\n    getEstimatedSize: getEstimatedHeight,\n    startIndexOverscan: rowStartIndexOverscan,\n    startIndexVisible: rowStartIndexVisible,\n    scrollToIndex: scrollToRowIndex,\n    stopIndexOverscan: rowStopIndexOverscan,\n    stopIndexVisible: rowStopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: cellProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    gridRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToCell({\n        behavior = \"auto\",\n        columnAlign = \"auto\",\n        columnIndex,\n        rowAlign = \"auto\",\n        rowIndex\n      }: {\n        behavior?: ScrollBehavior;\n        columnAlign?: Align;\n        columnIndex: number;\n        rowAlign?: Align;\n        rowIndex: number;\n      }) {\n        const left = scrollToColumnIndex({\n          align: columnAlign,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index: columnIndex\n        });\n        const top = scrollToRowIndex({\n          align: rowAlign,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index: rowIndex\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            left,\n            top\n          });\n        }\n      },\n\n      scrollToColumn({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const left = scrollToColumnIndex({\n          align,\n          containerScrollOffset: element?.scrollLeft ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            left\n          });\n        }\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const top = scrollToRowIndex({\n          align,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            top\n          });\n        }\n      }\n    }),\n    [element, scrollToColumnIndex, scrollToRowIndex]\n  );\n\n  useEffect(() => {\n    if (\n      columnStartIndexOverscan >= 0 &&\n      columnStopIndexOverscan >= 0 &&\n      rowStartIndexOverscan >= 0 &&\n      rowStopIndexOverscan >= 0 &&\n      onCellsRendered\n    ) {\n      onCellsRendered(\n        {\n          columnStartIndex: columnStartIndexVisible,\n          columnStopIndex: columnStopIndexVisible,\n          rowStartIndex: rowStartIndexVisible,\n          rowStopIndex: rowStopIndexVisible\n        },\n        {\n          columnStartIndex: columnStartIndexOverscan,\n          columnStopIndex: columnStopIndexOverscan,\n          rowStartIndex: rowStartIndexOverscan,\n          rowStopIndex: rowStopIndexOverscan\n        }\n      );\n    }\n  }, [\n    onCellsRendered,\n    columnStartIndexOverscan,\n    columnStartIndexVisible,\n    columnStopIndexOverscan,\n    columnStopIndexVisible,\n    rowStartIndexOverscan,\n    rowStartIndexVisible,\n    rowStopIndexOverscan,\n    rowStopIndexVisible\n  ]);\n\n  const cells = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (columnCount > 0 && rowCount > 0) {\n      for (\n        let rowIndex = rowStartIndexOverscan;\n        rowIndex <= rowStopIndexOverscan;\n        rowIndex++\n      ) {\n        const rowBounds = getRowBounds(rowIndex);\n\n        const columns: ReactNode[] = [];\n\n        for (\n          let columnIndex = columnStartIndexOverscan;\n          columnIndex <= columnStopIndexOverscan;\n          columnIndex++\n        ) {\n          const columnBounds = getColumnBounds(columnIndex);\n\n          columns.push(\n            <CellComponent\n              {...(cellProps as CellProps)}\n              ariaAttributes={{\n                \"aria-colindex\": columnIndex + 1,\n                role: \"gridcell\"\n              }}\n              columnIndex={columnIndex}\n              key={columnIndex}\n              rowIndex={rowIndex}\n              style={{\n                position: \"absolute\",\n                left: isRtl ? undefined : 0,\n                right: isRtl ? 0 : undefined,\n                transform: `translate(${isRtl ? -columnBounds.scrollOffset : columnBounds.scrollOffset}px, ${rowBounds.scrollOffset}px)`,\n                height: rowBounds.size,\n                width: columnBounds.size\n              }}\n            />\n          );\n        }\n\n        children.push(\n          <div key={rowIndex} role=\"row\" aria-rowindex={rowIndex + 1}>\n            {columns}\n          </div>\n        );\n      }\n    }\n    return children;\n  }, [\n    CellComponent,\n    cellProps,\n    columnCount,\n    columnStartIndexOverscan,\n    columnStopIndexOverscan,\n    getColumnBounds,\n    getRowBounds,\n    isRtl,\n    rowCount,\n    rowStartIndexOverscan,\n    rowStopIndexOverscan\n  ]);\n\n  const sizingElement = (\n    <div\n      aria-hidden\n      style={{\n        height: getEstimatedHeight(),\n        width: getEstimatedWidth(),\n        zIndex: -1\n      }}\n    ></div>\n  );\n\n  return createElement(\n    tagName,\n    {\n      \"aria-colcount\": columnCount,\n      \"aria-rowcount\": rowCount,\n      role: \"grid\",\n      ...rest,\n      className,\n      dir,\n      ref: setElement,\n      style: {\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100%\",\n        maxHeight: \"100%\",\n        maxWidth: \"100%\",\n        flexGrow: 1,\n        overflow: \"auto\",\n        ...style\n      }\n    },\n    cells,\n    children,\n    sizingElement\n  );\n}\n","import { useState } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Grid component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useGridCallbackRef =\n  useState as typeof useState<GridImperativeAPI | null>;\n","import { useRef } from \"react\";\nimport type { GridImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Grid component.\n */\nexport const useGridRef = useRef as typeof useRef<GridImperativeAPI>;\n","import type { DynamicRowHeight } from \"./types\";\n\nexport function isDynamicRowHeight(value: unknown): value is DynamicRowHeight {\n  return (\n    value != null &&\n    typeof value === \"object\" &&\n    \"getAverageRowHeight\" in value &&\n    typeof value.getAverageRowHeight === \"function\"\n  );\n}\n","import {\n  createElement,\n  memo,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState,\n  type ReactNode\n} from \"react\";\nimport { useVirtualizer } from \"../../core/useVirtualizer\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMemoizedObject } from \"../../hooks/useMemoizedObject\";\nimport type { Align, TagNames } from \"../../types\";\nimport { arePropsEqual } from \"../../utils/arePropsEqual\";\nimport { isDynamicRowHeight as isDynamicRowHeightUtil } from \"./isDynamicRowHeight\";\nimport type { ListProps } from \"./types\";\n\nexport const DATA_ATTRIBUTE_LIST_INDEX = \"data-react-window-index\";\n\nexport function List<\n  RowProps extends object,\n  TagName extends TagNames = \"div\"\n>({\n  children,\n  className,\n  defaultHeight = 0,\n  listRef,\n  onResize,\n  onRowsRendered,\n  overscanCount = 3,\n  rowComponent: RowComponentProp,\n  rowCount,\n  rowHeight: rowHeightProp,\n  rowProps: rowPropsUnstable,\n  tagName = \"div\" as TagName,\n  style,\n  ...rest\n}: ListProps<RowProps, TagName>) {\n  const rowProps = useMemoizedObject(rowPropsUnstable);\n  const RowComponent = useMemo(\n    () => memo(RowComponentProp, arePropsEqual),\n    [RowComponentProp]\n  );\n\n  const [element, setElement] = useState<HTMLDivElement | null>(null);\n\n  const isDynamicRowHeight = isDynamicRowHeightUtil(rowHeightProp);\n\n  const rowHeight = useMemo(() => {\n    if (isDynamicRowHeight) {\n      return (index: number) => {\n        return (\n          rowHeightProp.getRowHeight(index) ??\n          rowHeightProp.getAverageRowHeight()\n        );\n      };\n    }\n\n    return rowHeightProp;\n  }, [isDynamicRowHeight, rowHeightProp]);\n\n  const {\n    getCellBounds,\n    getEstimatedSize,\n    scrollToIndex,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  } = useVirtualizer({\n    containerElement: element,\n    containerStyle: style,\n    defaultContainerSize: defaultHeight,\n    direction: \"vertical\",\n    itemCount: rowCount,\n    itemProps: rowProps,\n    itemSize: rowHeight,\n    onResize,\n    overscanCount\n  });\n\n  useImperativeHandle(\n    listRef,\n    () => ({\n      get element() {\n        return element;\n      },\n\n      scrollToRow({\n        align = \"auto\",\n        behavior = \"auto\",\n        index\n      }: {\n        align?: Align;\n        behavior?: ScrollBehavior;\n        index: number;\n      }) {\n        const top = scrollToIndex({\n          align,\n          containerScrollOffset: element?.scrollTop ?? 0,\n          index\n        });\n\n        if (typeof element?.scrollTo === \"function\") {\n          element.scrollTo({\n            behavior,\n            top\n          });\n        }\n      }\n    }),\n    [element, scrollToIndex]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      return;\n    }\n\n    const rows = Array.from(element.children).filter((item, index) => {\n      if (item.hasAttribute(\"aria-hidden\")) {\n        // Ignore sizing element\n        return false;\n      }\n\n      const attribute = `${startIndexOverscan + index}`;\n      item.setAttribute(DATA_ATTRIBUTE_LIST_INDEX, attribute);\n\n      return true;\n    });\n\n    if (isDynamicRowHeight) {\n      return rowHeightProp.observeRowElements(rows);\n    }\n  }, [\n    element,\n    isDynamicRowHeight,\n    rowHeightProp,\n    startIndexOverscan,\n    stopIndexOverscan\n  ]);\n\n  useEffect(() => {\n    if (startIndexOverscan >= 0 && stopIndexOverscan >= 0 && onRowsRendered) {\n      onRowsRendered(\n        {\n          startIndex: startIndexVisible,\n          stopIndex: stopIndexVisible\n        },\n        {\n          startIndex: startIndexOverscan,\n          stopIndex: stopIndexOverscan\n        }\n      );\n    }\n  }, [\n    onRowsRendered,\n    startIndexOverscan,\n    startIndexVisible,\n    stopIndexOverscan,\n    stopIndexVisible\n  ]);\n\n  const rows = useMemo(() => {\n    const children: ReactNode[] = [];\n    if (rowCount > 0) {\n      for (\n        let index = startIndexOverscan;\n        index <= stopIndexOverscan;\n        index++\n      ) {\n        const bounds = getCellBounds(index);\n\n        children.push(\n          <RowComponent\n            {...(rowProps as RowProps)}\n            ariaAttributes={{\n              \"aria-posinset\": index + 1,\n              \"aria-setsize\": rowCount,\n              role: \"listitem\"\n            }}\n            key={index}\n            index={index}\n            style={{\n              position: \"absolute\",\n              left: 0,\n              transform: `translateY(${bounds.scrollOffset}px)`,\n              // In case of dynamic row heights, don't specify a height style\n              // otherwise a default/estimated height would mask the actual height\n              height: isDynamicRowHeight ? undefined : bounds.size,\n              width: \"100%\"\n            }}\n          />\n        );\n      }\n    }\n    return children;\n  }, [\n    RowComponent,\n    getCellBounds,\n    isDynamicRowHeight,\n    rowCount,\n    rowProps,\n    startIndexOverscan,\n    stopIndexOverscan\n  ]);\n\n  const sizingElement = (\n    <div\n      aria-hidden\n      style={{\n        height: getEstimatedSize(),\n        width: \"100%\",\n        zIndex: -1\n      }}\n    ></div>\n  );\n\n  return createElement(\n    tagName,\n    {\n      role: \"list\",\n      ...rest,\n      className,\n      ref: setElement,\n      style: {\n        position: \"relative\",\n        maxHeight: \"100%\",\n        flexGrow: 1,\n        overflowY: \"auto\",\n        ...style\n      }\n    },\n    rows,\n    children,\n    sizingElement\n  );\n}\n","import { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { assert } from \"../../utils/assert\";\nimport { DATA_ATTRIBUTE_LIST_INDEX } from \"./List\";\nimport type { DynamicRowHeight } from \"./types\";\n\nexport function useDynamicRowHeight({\n  defaultRowHeight,\n  key\n}: {\n  defaultRowHeight: number;\n  key?: string | number;\n}) {\n  const [state, setState] = useState<{\n    key: string | number | undefined;\n    map: Map<number, number>;\n  }>({\n    key,\n    map: new Map()\n  });\n\n  if (state.key !== key) {\n    setState({\n      key,\n      map: new Map()\n    });\n  }\n\n  const { map } = state;\n\n  const getAverageRowHeight = useCallback(() => {\n    let totalHeight = 0;\n\n    map.forEach((height) => {\n      totalHeight += height;\n    });\n\n    if (totalHeight === 0) {\n      return defaultRowHeight;\n    }\n\n    return totalHeight / map.size;\n  }, [defaultRowHeight, map]);\n\n  const getRowHeight = useCallback(\n    (index: number) => {\n      return map.get(index);\n    },\n    [map]\n  );\n\n  const setRowHeight = useCallback((index: number, size: number) => {\n    setState((prevState) => {\n      if (prevState.map.get(index) === size) {\n        return prevState;\n      }\n\n      const clonedMap = new Map(prevState.map);\n      clonedMap.set(index, size);\n\n      return {\n        ...prevState,\n        map: clonedMap\n      };\n    });\n  }, []);\n\n  const resizeObserverCallback = useStableCallback(\n    (entries: ResizeObserverEntry[]) => {\n      if (entries.length === 0) {\n        return;\n      }\n\n      entries.forEach((entry) => {\n        const { borderBoxSize, target } = entry;\n\n        const attribute = target.getAttribute(DATA_ATTRIBUTE_LIST_INDEX);\n        assert(\n          attribute !== null,\n          `Invalid ${DATA_ATTRIBUTE_LIST_INDEX} attribute value`\n        );\n\n        const index = parseInt(attribute);\n\n        const { blockSize: height } = borderBoxSize[0];\n        if (!height) {\n          // Ignore heights that have not yet been measured (e.g. <img> elements that have not yet loaded)\n          return;\n        }\n\n        setRowHeight(index, height);\n      });\n    }\n  );\n\n  const [resizeObserver] = useState(\n    () => new ResizeObserver(resizeObserverCallback)\n  );\n\n  useEffect(() => {\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [resizeObserver]);\n\n  const observeRowElements = useCallback(\n    (elements: Element[] | NodeListOf<Element>) => {\n      elements.forEach((element) => resizeObserver.observe(element));\n      return () => {\n        elements.forEach((element) => resizeObserver.unobserve(element));\n      };\n    },\n    [resizeObserver]\n  );\n\n  return useMemo<DynamicRowHeight>(\n    () => ({\n      getAverageRowHeight,\n      getRowHeight,\n      setRowHeight,\n      observeRowElements\n    }),\n    [getAverageRowHeight, getRowHeight, setRowHeight, observeRowElements]\n  );\n}\n","import { useState } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the List component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport const useListCallbackRef =\n  useState as typeof useState<ListImperativeAPI | null>;\n","import { useRef } from \"react\";\nimport type { ListImperativeAPI } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the List component.\n */\nexport const useListRef = useRef as typeof useRef<ListImperativeAPI>;\n","let size: number = -1;\n\nexport function getScrollbarSize(recalculate: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement(\"div\");\n    const style = div.style;\n    style.width = \"50px\";\n    style.height = \"50px\";\n    style.overflow = \"scroll\";\n\n    document.body.appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nexport function setScrollbarSizeForTests(value: number) {\n  size = value;\n}\n"],"names":["isRtl","element","currentElement","useIsRtl","dir","value","setValue","useState","useLayoutEffect","useIsomorphicLayoutEffect","useEffect","parseNumericStyleValue","useResizeObserver","box","defaultHeight","defaultWidth","disabledProp","mode","style","styleHeight","styleWidth","useMemo","state","setState","disabled","resizeObserver","entries","entry","contentRect","target","prevState","useStableCallback","fn","ref","useRef","useCallback","args","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","outerStyle","innerDiv","innerStyle","adjustScrollOffsetForRtl","containerElement","direction","scrollOffset","clientWidth","scrollLeft","scrollWidth","assert","expectedCondition","message","shallowCompare","a","b","key","getEstimatedSize","cachedBounds","itemCount","itemSize","bounds","averageItemSize","getOffsetForIndex","align","index","containerScrollOffset","containerSize","estimatedTotalSize","maxOffset","minOffset","getStartStopIndices","overscanCount","maxIndex","startIndexVisible","stopIndexVisible","startIndexOverscan","stopIndexOverscan","currentIndex","createCachedBounds","itemProps","cache","size","previousRowBounds","useCachedBounds","useItemSize","itemSizeProp","useVirtualizer","containerStyle","defaultContainerSize","onResize","indices","setIndices","height","width","prevSizeRef","prevSize","getCellBounds","getEstimatedSizeUtil","getStartStopIndicesUtil","onScroll","prev","scrollTop","next","scrollToIndex","useMemoizedObject","unstableObject","arePropsEqual","prevProps","nextProps","prevAriaAttributes","prevStyle","prevRest","nextAriaAttributes","nextStyle","nextRest","Grid","CellComponentProp","cellPropsUnstable","children","className","columnCount","columnWidth","gridRef","onCellsRendered","rowCount","rowHeight","tagName","rest","cellProps","CellComponent","memo","setElement","getColumnBounds","getEstimatedWidth","columnStartIndexOverscan","columnStartIndexVisible","scrollToColumnIndex","columnStopIndexOverscan","columnStopIndexVisible","getRowBounds","getEstimatedHeight","rowStartIndexOverscan","rowStartIndexVisible","scrollToRowIndex","rowStopIndexOverscan","rowStopIndexVisible","useImperativeHandle","behavior","columnAlign","columnIndex","rowAlign","rowIndex","left","top","cells","rowBounds","columns","columnBounds","createElement","jsx","sizingElement","useGridCallbackRef","useGridRef","isDynamicRowHeight","DATA_ATTRIBUTE_LIST_INDEX","List","listRef","onRowsRendered","RowComponentProp","rowHeightProp","rowPropsUnstable","rowProps","RowComponent","isDynamicRowHeightUtil","rows","item","attribute","useDynamicRowHeight","defaultRowHeight","map","getAverageRowHeight","totalHeight","getRowHeight","setRowHeight","clonedMap","resizeObserverCallback","borderBoxSize","observeRowElements","elements","useListCallbackRef","useListRef","getScrollbarSize","div"],"mappings":"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"}