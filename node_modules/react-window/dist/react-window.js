import { jsx as P } from "react/jsx-runtime";
import { useState as $, useLayoutEffect as se, useEffect as J, useMemo as L, useRef as K, useCallback as U, memo as le, useImperativeHandle as ce, createElement as X } from "react";
function xe(e) {
  let t = e;
  for (; t; ) {
    if (t.dir)
      return t.dir === "rtl";
    t = t.parentElement;
  }
  return !1;
}
function ve(e, t) {
  const [s, r] = $(t === "rtl");
  return se(() => {
    e && (t || r(xe(e)));
  }, [t, e]), s;
}
const q = typeof window < "u" ? se : J;
function oe(e) {
  if (e !== void 0)
    switch (typeof e) {
      case "number":
        return e;
      case "string": {
        if (e.endsWith("px"))
          return parseFloat(e);
        break;
      }
    }
}
function be({
  box: e,
  defaultHeight: t,
  defaultWidth: s,
  disabled: r,
  element: n,
  mode: o,
  style: i
}) {
  const { styleHeight: a, styleWidth: l } = L(
    () => ({
      styleHeight: oe(i?.height),
      styleWidth: oe(i?.width)
    }),
    [i?.height, i?.width]
  ), [c, d] = $({
    height: t,
    width: s
  }), f = r || o === "only-height" && a !== void 0 || o === "only-width" && l !== void 0 || a !== void 0 && l !== void 0;
  return q(() => {
    if (n === null || f)
      return;
    const p = new ResizeObserver((b) => {
      for (const m of b) {
        const { contentRect: I, target: g } = m;
        n === g && d((w) => w.height === I.height && w.width === I.width ? w : {
          height: I.height,
          width: I.width
        });
      }
    });
    return p.observe(n, { box: e }), () => {
      p?.unobserve(n);
    };
  }, [e, f, n, a, l]), L(
    () => ({
      height: a ?? c.height,
      width: l ?? c.width
    }),
    [c, a, l]
  );
}
function ae(e) {
  const t = K(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  return q(() => {
    t.current = e;
  }, [e]), U((s) => t.current?.(s), [t]);
}
let F = null;
function Ie(e = !1) {
  if (F === null || e) {
    const t = document.createElement("div"), s = t.style;
    s.width = "50px", s.height = "50px", s.overflow = "scroll", s.direction = "rtl";
    const r = document.createElement("div"), n = r.style;
    return n.width = "100px", n.height = "100px", t.appendChild(r), document.body.appendChild(t), t.scrollLeft > 0 ? F = "positive-descending" : (t.scrollLeft = 1, t.scrollLeft === 0 ? F = "negative" : F = "positive-ascending"), document.body.removeChild(t), F;
  }
  return F;
}
function Z({
  containerElement: e,
  direction: t,
  isRtl: s,
  scrollOffset: r
}) {
  if (t === "horizontal" && s)
    switch (Ie()) {
      case "negative":
        return -r;
      case "positive-descending": {
        if (e) {
          const { clientWidth: n, scrollLeft: o, scrollWidth: i } = e;
          return i - n - o;
        }
        break;
      }
    }
  return r;
}
function H(e, t = "Assertion error") {
  if (!e)
    throw console.error(t), Error(t);
}
function Y(e, t) {
  if (e === t)
    return !0;
  if (!!e != !!t || (H(e !== void 0), H(t !== void 0), Object.keys(e).length !== Object.keys(t).length))
    return !1;
  for (const s in e)
    if (!Object.is(t[s], e[s]))
      return !1;
  return !0;
}
function fe({
  cachedBounds: e,
  itemCount: t,
  itemSize: s
}) {
  if (t === 0)
    return 0;
  if (typeof s == "number")
    return t * s;
  {
    const r = e.get(
      e.size === 0 ? 0 : e.size - 1
    );
    H(r !== void 0, "Unexpected bounds cache miss");
    const n = (r.scrollOffset + r.size) / e.size;
    return t * n;
  }
}
function we({
  align: e,
  cachedBounds: t,
  index: s,
  itemCount: r,
  itemSize: n,
  containerScrollOffset: o,
  containerSize: i
}) {
  const a = fe({
    cachedBounds: t,
    itemCount: r,
    itemSize: n
  }), l = t.get(s), c = Math.max(
    0,
    Math.min(a - i, l.scrollOffset)
  ), d = Math.max(
    0,
    l.scrollOffset - i + l.size
  );
  switch (e === "smart" && (o >= d && o <= c ? e = "auto" : e = "center"), e) {
    case "start":
      return c;
    case "end":
      return d;
    case "center":
      return l.scrollOffset <= i / 2 ? 0 : l.scrollOffset + l.size / 2 >= a - i / 2 ? a - i : l.scrollOffset + l.size / 2 - i / 2;
    case "auto":
    default:
      return o >= d && o <= c ? o : o < d ? d : c;
  }
}
function ie({
  cachedBounds: e,
  containerScrollOffset: t,
  containerSize: s,
  itemCount: r,
  overscanCount: n
}) {
  const o = r - 1;
  let i = 0, a = -1, l = 0, c = -1, d = 0;
  for (; d < o; ) {
    const f = e.get(d);
    if (f.scrollOffset + f.size > t)
      break;
    d++;
  }
  for (i = d, l = Math.max(0, i - n); d < o; ) {
    const f = e.get(d);
    if (f.scrollOffset + f.size >= t + s)
      break;
    d++;
  }
  return a = Math.min(o, d), c = Math.min(r - 1, a + n), i < 0 && (i = 0, a = -1, l = 0, c = -1), {
    startIndexVisible: i,
    stopIndexVisible: a,
    startIndexOverscan: l,
    stopIndexOverscan: c
  };
}
function me({
  itemCount: e,
  itemProps: t,
  itemSize: s
}) {
  const r = /* @__PURE__ */ new Map();
  return {
    get(n) {
      for (H(n < e, `Invalid index ${n}`); r.size - 1 < n; ) {
        const i = r.size;
        let a;
        switch (typeof s) {
          case "function": {
            a = s(i, t);
            break;
          }
          case "number": {
            a = s;
            break;
          }
        }
        if (i === 0)
          r.set(i, {
            size: a,
            scrollOffset: 0
          });
        else {
          const l = r.get(i - 1);
          H(
            l !== void 0,
            `Unexpected bounds cache miss for index ${n}`
          ), r.set(i, {
            scrollOffset: l.scrollOffset + l.size,
            size: a
          });
        }
      }
      const o = r.get(n);
      return H(
        o !== void 0,
        `Unexpected bounds cache miss for index ${n}`
      ), o;
    },
    set(n, o) {
      r.set(n, o);
    },
    get size() {
      return r.size;
    }
  };
}
function Oe({
  itemCount: e,
  itemProps: t,
  itemSize: s
}) {
  return L(
    () => me({
      itemCount: e,
      itemProps: t,
      itemSize: s
    }),
    [e, t, s]
  );
}
function ye({
  containerSize: e,
  itemSize: t
}) {
  let s;
  switch (typeof t) {
    case "string": {
      H(
        t.endsWith("%"),
        `Invalid item size: "${t}"; string values must be percentages (e.g. "100%")`
      ), H(
        e !== void 0,
        "Container size must be defined if a percentage item size is specified"
      ), s = e * parseInt(t) / 100;
      break;
    }
    default: {
      s = t;
      break;
    }
  }
  return s;
}
function ee({
  containerElement: e,
  containerStyle: t,
  defaultContainerSize: s = 0,
  direction: r,
  isRtl: n = !1,
  itemCount: o,
  itemProps: i,
  itemSize: a,
  onResize: l,
  overscanCount: c
}) {
  const [d, f] = $({
    startIndexVisible: 0,
    startIndexOverscan: 0,
    stopIndexVisible: -1,
    stopIndexOverscan: -1
  }), {
    startIndexVisible: p,
    startIndexOverscan: b,
    stopIndexVisible: m,
    stopIndexOverscan: I
  } = {
    startIndexVisible: Math.min(o - 1, d.startIndexVisible),
    startIndexOverscan: Math.min(o - 1, d.startIndexOverscan),
    stopIndexVisible: Math.min(o - 1, d.stopIndexVisible),
    stopIndexOverscan: Math.min(o - 1, d.stopIndexOverscan)
  }, { height: g = s, width: w = s } = be({
    defaultHeight: r === "vertical" ? s : void 0,
    defaultWidth: r === "horizontal" ? s : void 0,
    element: e,
    mode: r === "vertical" ? "only-height" : "only-width",
    style: t
  }), y = K({
    height: 0,
    width: 0
  }), V = r === "vertical" ? g : w, u = ye({ containerSize: V, itemSize: a });
  se(() => {
    if (typeof l == "function") {
      const h = y.current;
      (h.height !== g || h.width !== w) && (l({ height: g, width: w }, { ...h }), h.height = g, h.width = w);
    }
  }, [g, l, w]);
  const z = Oe({
    itemCount: o,
    itemProps: i,
    itemSize: u
  }), k = U(
    (h) => z.get(h),
    [z]
  ), S = U(
    () => fe({
      cachedBounds: z,
      itemCount: o,
      itemSize: u
    }),
    [z, o, u]
  ), W = U(
    (h) => {
      const T = Z({
        containerElement: e,
        direction: r,
        isRtl: n,
        scrollOffset: h
      });
      return ie({
        cachedBounds: z,
        containerScrollOffset: T,
        containerSize: V,
        itemCount: o,
        overscanCount: c
      });
    },
    [
      z,
      e,
      V,
      r,
      n,
      o,
      c
    ]
  );
  q(() => {
    const h = (r === "vertical" ? e?.scrollTop : e?.scrollLeft) ?? 0;
    f(W(h));
  }, [e, r, W]), q(() => {
    if (!e)
      return;
    const h = () => {
      f((T) => {
        const { scrollLeft: E, scrollTop: v } = e, x = Z({
          containerElement: e,
          direction: r,
          isRtl: n,
          scrollOffset: r === "vertical" ? v : E
        }), A = ie({
          cachedBounds: z,
          containerScrollOffset: x,
          containerSize: V,
          itemCount: o,
          overscanCount: c
        });
        return Y(A, T) ? T : A;
      });
    };
    return e.addEventListener("scroll", h), () => {
      e.removeEventListener("scroll", h);
    };
  }, [
    z,
    e,
    V,
    r,
    o,
    c
  ]);
  const O = ae(
    ({
      align: h = "auto",
      containerScrollOffset: T,
      index: E
    }) => {
      let v = we({
        align: h,
        cachedBounds: z,
        containerScrollOffset: T,
        containerSize: V,
        index: E,
        itemCount: o,
        itemSize: u
      });
      if (e) {
        if (v = Z({
          containerElement: e,
          direction: r,
          isRtl: n,
          scrollOffset: v
        }), typeof e.scrollTo != "function") {
          const x = W(v);
          Y(d, x) || f(x);
        }
        return v;
      }
    }
  );
  return {
    getCellBounds: k,
    getEstimatedSize: S,
    scrollToIndex: O,
    startIndexOverscan: b,
    startIndexVisible: p,
    stopIndexOverscan: I,
    stopIndexVisible: m
  };
}
function de(e) {
  return L(() => e, Object.values(e));
}
function ue(e, t) {
  const {
    ariaAttributes: s,
    style: r,
    ...n
  } = e, {
    ariaAttributes: o,
    style: i,
    ...a
  } = t;
  return Y(s, o) && Y(r, i) && Y(n, a);
}
function Re({
  cellComponent: e,
  cellProps: t,
  children: s,
  className: r,
  columnCount: n,
  columnWidth: o,
  defaultHeight: i = 0,
  defaultWidth: a = 0,
  dir: l,
  gridRef: c,
  onCellsRendered: d,
  onResize: f,
  overscanCount: p = 3,
  rowCount: b,
  rowHeight: m,
  style: I,
  tagName: g = "div",
  ...w
}) {
  const y = de(t), V = L(
    () => le(e, ue),
    [e]
  ), [u, z] = $(null), k = ve(u, l), {
    getCellBounds: S,
    getEstimatedSize: W,
    startIndexOverscan: O,
    startIndexVisible: h,
    scrollToIndex: T,
    stopIndexOverscan: E,
    stopIndexVisible: v
  } = ee({
    containerElement: u,
    containerStyle: I,
    defaultContainerSize: a,
    direction: "horizontal",
    isRtl: k,
    itemCount: n,
    itemProps: y,
    itemSize: o,
    onResize: f,
    overscanCount: p
  }), {
    getCellBounds: x,
    getEstimatedSize: A,
    startIndexOverscan: M,
    startIndexVisible: re,
    scrollToIndex: Q,
    stopIndexOverscan: _,
    stopIndexVisible: ne
  } = ee({
    containerElement: u,
    containerStyle: I,
    defaultContainerSize: i,
    direction: "vertical",
    itemCount: b,
    itemProps: y,
    itemSize: m,
    onResize: f,
    overscanCount: p
  });
  ce(
    c,
    () => ({
      get element() {
        return u;
      },
      scrollToCell({
        behavior: B = "auto",
        columnAlign: R = "auto",
        columnIndex: j,
        rowAlign: D = "auto",
        rowIndex: G
      }) {
        const N = T({
          align: R,
          containerScrollOffset: u?.scrollLeft ?? 0,
          index: j
        }), ge = Q({
          align: D,
          containerScrollOffset: u?.scrollTop ?? 0,
          index: G
        });
        typeof u?.scrollTo == "function" && u.scrollTo({
          behavior: B,
          left: N,
          top: ge
        });
      },
      scrollToColumn({
        align: B = "auto",
        behavior: R = "auto",
        index: j
      }) {
        const D = T({
          align: B,
          containerScrollOffset: u?.scrollLeft ?? 0,
          index: j
        });
        typeof u?.scrollTo == "function" && u.scrollTo({
          behavior: R,
          left: D
        });
      },
      scrollToRow({
        align: B = "auto",
        behavior: R = "auto",
        index: j
      }) {
        const D = Q({
          align: B,
          containerScrollOffset: u?.scrollTop ?? 0,
          index: j
        });
        typeof u?.scrollTo == "function" && u.scrollTo({
          behavior: R,
          top: D
        });
      }
    }),
    [u, T, Q]
  ), J(() => {
    O >= 0 && E >= 0 && M >= 0 && _ >= 0 && d && d(
      {
        columnStartIndex: h,
        columnStopIndex: v,
        rowStartIndex: re,
        rowStopIndex: ne
      },
      {
        columnStartIndex: O,
        columnStopIndex: E,
        rowStartIndex: M,
        rowStopIndex: _
      }
    );
  }, [
    d,
    O,
    h,
    E,
    v,
    M,
    re,
    _,
    ne
  ]);
  const he = L(() => {
    const B = [];
    if (n > 0 && b > 0)
      for (let R = M; R <= _; R++) {
        const j = x(R), D = [];
        for (let G = O; G <= E; G++) {
          const N = S(G);
          D.push(
            /* @__PURE__ */ X(
              V,
              {
                ...y,
                ariaAttributes: {
                  "aria-colindex": G + 1,
                  role: "gridcell"
                },
                columnIndex: G,
                key: G,
                rowIndex: R,
                style: {
                  position: "absolute",
                  left: k ? void 0 : 0,
                  right: k ? 0 : void 0,
                  transform: `translate(${k ? -N.scrollOffset : N.scrollOffset}px, ${j.scrollOffset}px)`,
                  height: j.size,
                  width: N.size
                }
              }
            )
          );
        }
        B.push(
          /* @__PURE__ */ P("div", { role: "row", "aria-rowindex": R + 1, children: D }, R)
        );
      }
    return B;
  }, [
    V,
    y,
    n,
    O,
    E,
    S,
    x,
    k,
    b,
    M,
    _
  ]), pe = /* @__PURE__ */ P(
    "div",
    {
      "aria-hidden": !0,
      style: {
        height: A(),
        width: W(),
        zIndex: -1
      }
    }
  );
  return X(
    g,
    {
      "aria-colcount": n,
      "aria-rowcount": b,
      role: "grid",
      ...w,
      className: r,
      dir: l,
      ref: z,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        maxHeight: "100%",
        maxWidth: "100%",
        flexGrow: 1,
        overflow: "auto",
        ...I
      }
    },
    he,
    s,
    pe
  );
}
const Ve = $, Ee = K;
function ze(e) {
  return e != null && typeof e == "object" && "getAverageRowHeight" in e && typeof e.getAverageRowHeight == "function";
}
const te = "data-react-window-index";
function Ae({
  children: e,
  className: t,
  defaultHeight: s = 0,
  listRef: r,
  onResize: n,
  onRowsRendered: o,
  overscanCount: i = 3,
  rowComponent: a,
  rowCount: l,
  rowHeight: c,
  rowProps: d,
  tagName: f = "div",
  style: p,
  ...b
}) {
  const m = de(d), I = L(
    () => le(a, ue),
    [a]
  ), [g, w] = $(null), y = ze(c), V = L(() => y ? (v) => c.getRowHeight(v) ?? c.getAverageRowHeight() : c, [y, c]), {
    getCellBounds: u,
    getEstimatedSize: z,
    scrollToIndex: k,
    startIndexOverscan: S,
    startIndexVisible: W,
    stopIndexOverscan: O,
    stopIndexVisible: h
  } = ee({
    containerElement: g,
    containerStyle: p,
    defaultContainerSize: s,
    direction: "vertical",
    itemCount: l,
    itemProps: m,
    itemSize: V,
    onResize: n,
    overscanCount: i
  });
  ce(
    r,
    () => ({
      get element() {
        return g;
      },
      scrollToRow({
        align: v = "auto",
        behavior: x = "auto",
        index: A
      }) {
        const M = k({
          align: v,
          containerScrollOffset: g?.scrollTop ?? 0,
          index: A
        });
        typeof g?.scrollTo == "function" && g.scrollTo({
          behavior: x,
          top: M
        });
      }
    }),
    [g, k]
  ), q(() => {
    if (!g)
      return;
    const v = Array.from(g.children).filter((x, A) => {
      if (x.hasAttribute("aria-hidden"))
        return !1;
      const M = `${S + A}`;
      return x.setAttribute(te, M), !0;
    });
    if (y)
      return c.observeRowElements(v);
  }, [
    g,
    y,
    c,
    S,
    O
  ]), J(() => {
    S >= 0 && O >= 0 && o && o(
      {
        startIndex: W,
        stopIndex: h
      },
      {
        startIndex: S,
        stopIndex: O
      }
    );
  }, [
    o,
    S,
    W,
    O,
    h
  ]);
  const T = L(() => {
    const v = [];
    if (l > 0)
      for (let x = S; x <= O; x++) {
        const A = u(x);
        v.push(
          /* @__PURE__ */ X(
            I,
            {
              ...m,
              ariaAttributes: {
                "aria-posinset": x + 1,
                "aria-setsize": l,
                role: "listitem"
              },
              key: x,
              index: x,
              style: {
                position: "absolute",
                left: 0,
                transform: `translateY(${A.scrollOffset}px)`,
                // In case of dynamic row heights, don't specify a height style
                // otherwise a default/estimated height would mask the actual height
                height: y ? void 0 : A.size,
                width: "100%"
              }
            }
          )
        );
      }
    return v;
  }, [
    I,
    u,
    y,
    l,
    m,
    S,
    O
  ]), E = /* @__PURE__ */ P(
    "div",
    {
      "aria-hidden": !0,
      style: {
        height: z(),
        width: "100%",
        zIndex: -1
      }
    }
  );
  return X(
    f,
    {
      role: "list",
      ...b,
      className: t,
      ref: w,
      style: {
        position: "relative",
        maxHeight: "100%",
        flexGrow: 1,
        overflowY: "auto",
        ...p
      }
    },
    T,
    e,
    E
  );
}
function ke({
  defaultRowHeight: e,
  key: t
}) {
  const [s, r] = $({
    key: t,
    map: /* @__PURE__ */ new Map()
  });
  s.key !== t && r({
    key: t,
    map: /* @__PURE__ */ new Map()
  });
  const { map: n } = s, o = U(() => {
    let f = 0;
    return n.forEach((p) => {
      f += p;
    }), f === 0 ? e : f / n.size;
  }, [e, n]), i = U(
    (f) => n.get(f),
    [n]
  ), a = U((f, p) => {
    r((b) => {
      if (b.map.get(f) === p)
        return b;
      const m = new Map(b.map);
      return m.set(f, p), {
        ...b,
        map: m
      };
    });
  }, []), l = ae(
    (f) => {
      f.length !== 0 && f.forEach((p) => {
        const { borderBoxSize: b, target: m } = p, I = m.getAttribute(te);
        H(
          I !== null,
          `Invalid ${te} attribute value`
        );
        const g = parseInt(I), { blockSize: w } = b[0];
        w && a(g, w);
      });
    }
  ), [c] = $(
    () => new ResizeObserver(l)
  );
  J(() => () => {
    c.disconnect();
  }, [c]);
  const d = U(
    (f) => (f.forEach((p) => c.observe(p)), () => {
      f.forEach((p) => c.unobserve(p));
    }),
    [c]
  );
  return L(
    () => ({
      getAverageRowHeight: o,
      getRowHeight: i,
      setRowHeight: a,
      observeRowElements: d
    }),
    [o, i, a, d]
  );
}
const Le = $, Me = K;
let C = -1;
function He(e = !1) {
  if (C === -1 || e) {
    const t = document.createElement("div"), s = t.style;
    s.width = "50px", s.height = "50px", s.overflow = "scroll", document.body.appendChild(t), C = t.offsetWidth - t.clientWidth, document.body.removeChild(t);
  }
  return C;
}
export {
  Re as Grid,
  Ae as List,
  He as getScrollbarSize,
  ke as useDynamicRowHeight,
  Ve as useGridCallbackRef,
  Ee as useGridRef,
  Le as useListCallbackRef,
  Me as useListRef
};
//# sourceMappingURL=react-window.js.map
